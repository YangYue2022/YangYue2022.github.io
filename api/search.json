[{"id":"9b3e5c64d9c6600c826b6e407be811c5","title":"数据结构（1）","content":"数据结构最近跟着 b 站上的王道课程重新学了一遍数据结构，因为时间来不及有一些知识点没有敲代码\n线性表顺序表#顺序表的静态存储\n#include &lt;stdio.h>\n#define MaxSize 10 // 定义最大长度\n\ntypedef struct &#123;\n\tint data[MaxSize];\n\tint length;\n&#125;SqList;\n// 初始化\nvoid InitList(SqList&amp; L) &#123;\n\tL.length = 0;\n&#125;\n// 根据位序i插入e元素\nbool ListInsert(SqList&amp; L, int i, int e) &#123;\n\tif (i &lt; 1 || i > L.length + 1) &#123; // 是否合法\n\t\treturn false;\n\t&#125;\n\tfor (int j = L.length; j >= i; j--) &#123;// 先向后移动\n\t\tL.data[j] = L.data[j - 1];\n\t&#125;\n\tL.data[i - 1] = e;// 再i-1位置放置e\n\tL.length++; // 长度+1\n\treturn true;\n&#125;\n// 根据位序i删除元素，返回删除的元素值e\nbool ListDelete(SqList&amp; L, int i, int&amp; e) &#123;\n\tif (i &lt; 1 || i > L.length) &#123;\n\t\treturn false;\n\t&#125;\n\te = L.data[i - 1];\n\tfor (int j = i; j &lt; L.length; j++) &#123;// 删除的位置后的元素往前移动\n\t\tL.data[j - 1] = L.data[j];\n\t&#125;\n\tL.length--;\n\treturn true;\n&#125;\n// 按位序i查找元素，返回值\nint GetElem(SqList&amp; L, int i) &#123;\n\tif (i &lt; 1 || i > L.length) &#123;\n\t\treturn 0;\n\t&#125;\n\treturn L.data[i - 1];\n&#125;\n// 按值e查找元素，返回位序\nint LocateElem(SqList&amp; L, int e) &#123;\n\tfor (int i = 0; i &lt; L.length; i++) &#123;\n\t\tif (e == L.data[i]) &#123;\n\t\t\treturn i + 1;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n// 遍历顺序表元素\nvoid PrintList(SqList&amp; L) &#123;\n\tfor (int i = 0; i &lt; L.length; i++) &#123;\n\t\tprintf(\"%d\\t\", L.data[i]);\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n链表不带头节点的单链表#include &lt;stdio.h>\n#include &lt;stdlib.h>\ntypedef struct node\n&#123;\n\tint data;\n\tstruct node* next;\n&#125; LNode, * LinkList;\n// 链表建立\nLinkList List_TailInsert(LinkList&amp; L) &#123;// 尾插法\n\tL=(LNode*)malloc(sizeof(LNode*));\n\tLNode *s=L,*t=NULL;\n\tL->next=NULL;\n\tint x;\n\tscanf(\"%d\",&amp;x);\n\twhile(x!=0)&#123;\n\t\t//s是新节点，t是尾节点\n\t\ts->data=x;\n\t\tif(t!=NULL)&#123;\n\t\t\tt->next=s;\n\t\t&#125;\n\t\tt=s;\n\t\tscanf(\"%d\",&amp;x);\n\t\ts=(LNode*)malloc(sizeof(LNode*));\n\t&#125;\n\tt->next=NULL;\n\treturn L;\n&#125;\n// 按位序i查找结点，1是第一个节点\nLNode* GetElem(LinkList&amp; L, int i) &#123;\n\tif (i &lt;= 0) &#123;\n\t\treturn NULL;\n\t&#125;\n\tint j = 1;\t\t\t\t\t// // 注意：不带头结点从1开始，首元结点的位序为1\n\tLNode* p = L;\t\t\t\t// 头结点开始\n\twhile (p != NULL &amp;&amp; j &lt; i) &#123;\t// 依次寻找\n\t\tp = p->next;\n\t\tj++;\n\t&#125;\n\treturn p;\n\n&#125;\n// 在位序i的位置插入结点操作\nbool ListInsert(LinkList&amp; L, int i, int e) &#123;\n\tif(i&lt;1) return false;\n\telse if(i==1)&#123; //如果在表头插入节点\n\t\tLNode* s=(LNode*)malloc(sizeof(LNode*));\n\t\ts->data=e;\n\t\ts->next=L->next;\n\t\tL=s;\n\n\t&#125;\n\telse&#123;\n\t\tLNode* s=GetElem(L,i-1);\n\t\tLNode* p=(LNode*)malloc(sizeof(LNode*));\n\t\tp->data=e;\n\t\tp->next=s->next;\n\t\ts->next=p;\n\n\t&#125;\n\treturn true;\n\n&#125;\n// 在位序i的位置删除结点操作\nbool ListDelete(LinkList&amp; L, int i, int&amp; e) &#123;\n\n\tif(i&lt;1) return false;\n\n\t//删除第一个节点\n\tif(i==1)&#123;\n\t\tLNode* temp=L;\n\t\tL=L->next;\n\t\tfree(temp);\n\t&#125;\n\n\t//删除后面的节点\n\tLNode* temp= GetElem(L,i-1);\n\tif(temp==NULL) return false;\n\tLNode*q=temp->next;\n\ttemp->next=q->next;\n\tfree(q);\n\treturn true;\n\n&#125;\n// 求表长\nint Length(LinkList&amp; L) &#123;\n\tint res=0;\n\tfor(LNode* i=L;i!=NULL;i=i->next)&#123;\n\t\tres++;\n\t&#125;\n\treturn res;\n&#125;\n// 链表输出\nvoid PrintLinkList(LinkList&amp; L) &#123;\n\tLNode* p = L;\n\twhile (p != NULL) &#123;\n\t\tprintf(\"%d\\t\", p->data);\n\t\tp = p->next;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n带头结点的单链表#include &lt;stdio.h>\n#include &lt;stdlib.h>\ntypedef struct LNode &#123;\n\tint data;\n\tstruct LNode* next;\n&#125;LNode,* LinkList;\n// 单链表的建立\nLNode* List_HeadInsert(LinkList&amp; l) &#123;// 头插法，建立逆序单链表\n\tl=(LNode*)malloc(sizeof(LNode));\n\tLNode* s;\n\tint x;\n\tl->next=NULL;\n\tscanf(\"%d\",&amp;x);\n\twhile(x!=0)&#123;\n\t\ts=(LNode*)malloc(sizeof(LNode));\n\t\ts->data=x;\n\t\ts->next=l->next;\n\t\tl->next=s;\n\t\tscanf(\"%d\",&amp;x);\n\t&#125;\n\treturn l;\n&#125;\nLNode* List_TailInsert(LinkList&amp; l) &#123;// 尾插法\n\tl=(LNode*)malloc(sizeof(LNode));\n\tl->next=NULL;\n\tLNode* s;\n\tLNode* temp=l;\n\tint x;\n\tscanf(\"%d\",&amp;x);\n\twhile(x!=0)&#123;\n\t\ts=(LNode*)malloc(sizeof(LNode));\n\t\ts->data=x;\n\t\ts->next=NULL;\n\t\ttemp->next=s;\n\t\ttemp=s;\n\t\tscanf(\"%d\",&amp;x);\n\t&#125;\n\ttemp->next=NULL;\n\treturn l;\n&#125;\n// 按位序i查找结点，头结点的位序是0，1是第一个节点\nLNode* GetElem(LNode* l, int i) &#123;\n\tif(i&lt;0) return NULL;\n\tLNode* s=l;\n\tint j=0;\n\twhile(j&lt;i&amp;&amp;s!=NULL)&#123;\n\t\tj++;\n\t\ts=s->next;\n\t&#125;\n\treturn s;\n&#125;\n// 按值e查找结点\nLNode* LocateElem(LNode* l, int e) &#123;\n\tfor(LNode* s=l->next;s!=NULL;s=s->next)&#123;\n\t\tif(s->data==e)&#123;\n\t\t\treturn s;\n\t\t&#125;\n\t&#125;\n\treturn NULL;\n&#125;\n// 后插操作：在结点p后插入新节点-方法1\nbool InsertNextNode(LNode* p, int e) &#123;\n\tif(p==NULL) return false;\n\tLNode* s=(LNode*)malloc(sizeof(LNode));\n\ts->data=e;\n\ts->next=p->next;\n\tp->next=s;\n\treturn true;\n&#125;\n// 前插操作：在结点p之前插入元素e-方法2\nbool InsertPriorNode(LNode* p, int e) &#123;\n\tif(p==NULL) return false;\n\tLNode* s=(LNode*)malloc(sizeof(LNode));\n\ts->next=p->next;\n\tp->next=s;\n\ts->data=p->data;\n\tp->data=e;\n\treturn true;\n&#125;\n// 在位序i的位置插入结点操作\nbool ListInsert(LNode* l, int i, int e) &#123;\n\tLNode* s=GetElem(l,i-1);\n\tInsertNextNode(s,e);\n&#125;\n// 在位序i的位置插入结点操作\nbool ListInsertBefore(LNode* l, int i, int e) &#123;\n\tLNode* s=GetElem(l,i);\n\tInsertPriorNode(s,e);\n&#125;\n// 在位序i的位置删除结点操作-方法1\nbool ListDelete(LNode* l, int i, int&amp; e) &#123;\n\tLNode* s=GetElem(l,i-1);\n\tif(s==NULL) return false;\n\tLNode* q=s->next;\n\ts->next=q->next;\n\te=q->data;\n\tfree(q);\n\treturn true;\n&#125;\n//  删除指定结点p, 不通过前驱节点操作，用交换数据那样删除，但是注意最后一个节点不能这样删除-方法2\nbool DeleteZhidingLNode(LNode* p) &#123;\n\tif(p==NULL||p->next==NULL) return false;\n\tLNode* s=p->next;\n\tp->data=s->data;\n\tp->next=s->next;\n\tfree(s);\n\treturn true;\n&#125;\n// 在位序i的位置删除结点操作\nbool ListDeleteZhiding(LNode* l, int i, int&amp; e) &#123;\n\n\tLNode* s=GetElem(l,i);\n\tif(s==NULL) return false;\n\te=s->data;\n\tDeleteZhidingLNode(s);\n\treturn true;\n&#125;\n// 求表长\nint Length(LNode* l) &#123;\n\tint i=0;\n\tfor(LNode* s=l;s->next!=NULL;s=s->next)&#123;\n\t\ti++;\n\t&#125;\n\treturn i;\n&#125;\n// 链表输出\nvoid PrintLinkList(LinkList&amp; l) &#123;\n\tprintf(\"开始打印\");\n\tLNode* p = l;\n\twhile (p->next != NULL) &#123;\n\t\tp = p->next;\n\t\tprintf(\"%d\\t\", p->data);// 放后面因为头结点是没有值的\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n带头结点的双链表#include &lt;stdio.h>\n#include &lt;stdlib.h>\ntypedef struct LNode &#123;\n\tint data;\n\tstruct LNode* next;// 下一个\n\tstruct LNode* prior;// 上一个\n&#125;LNode, * LinkList;\n// 双链表的建立\nLinkList List_TailInsert(LinkList&amp; l) &#123;// 尾插法\n\tl=(LNode*)malloc(sizeof(LNode));\n\tl->prior=NULL;\n\tLNode*temp=l;\n\tint x;\n\tscanf(\"%d\",&amp;x);\n\twhile(x!=0)&#123;\n\t\tLNode*s=(LNode*)malloc(sizeof(LNode));\n\t\ts->data=x;\n\t\ts->prior=temp;\n\t\ttemp->next=s;\n\t\ttemp=s;\n\t\tscanf(\"%d\",&amp;x);\n\t&#125;\n\ttemp->next=NULL;\n\treturn l;\n&#125;\n// 按位序i查找结点，头结点的位序是0，1是第一个节点\nLNode* GetElem(LinkList&amp; L, int i) &#123;\n\tLNode* s=L;\n\tint j=0;\n\twhile(j&lt;i&amp;&amp;s!=NULL)&#123;\n\t\ts=s->next;\n\t\tj++;\n\t&#125;\n\treturn s;\n&#125;\n// 按值e查找结点\nLNode* LocateElem(LinkList&amp; L, int e) &#123;\n\tLNode* s=L;\n\twhile(s!=NULL)&#123;\n\t\tif(s->data==e)&#123;\n\t\t\treturn s;\n\t\t&#125;\n\t\ts=s->next;\n\t&#125;\n\treturn s;\n&#125;\n//求表长\nint Length(LinkList&amp; L) &#123;\n\tint res=0;\n\tfor(LNode* i=L->next;i!=NULL;i=i->next)&#123;\n\t\tres++;\n\t&#125;\n\treturn res;\n&#125;\n\n// 在位序i的位置插入结点操作\nbool ListInsert(LinkList&amp; L, int i, int e) &#123;\n\tint length=Length(L);\n\tif(i&lt;1||i>length+1) return false;\n\n\n\t\tLNode* s=(LNode*)malloc(sizeof(LNode));\n\t\ts->data=e;\n\t\tLNode* pre=GetElem(L,i-1);\n\n\t\tLNode* next=pre->next;\n\t\tpre->next=s;\n\t\ts->prior=pre;\n\t\ts->next=next;\n\t\tif(next!=NULL)&#123;\n\t\t\tnext->prior=s;\n\t\t&#125;\n\t\treturn true;\n&#125;\n// 在位序i的位置删除结点操作\nbool ListDelete(LinkList&amp; L, int i, int&amp; e) &#123;\n\tint length=Length(L);\n\tif(i&lt;1||i>length) return false;\n\tLNode* temp=GetElem(L,i);\n\tLNode* pre=temp->prior;\n\tLNode* next=temp->next;\n\te=temp->data;\n\tpre->next=next;\n\tif(next!=NULL)&#123;\n\t\tnext->prior=pre;\n\t&#125;\n\treturn true;\n&#125;\n// 链表输出\nvoid PrintLinkList(LinkList&amp; L) &#123;\n\tLNode* p = L->next;\n\twhile (p != NULL) &#123;\n\n\t\tprintf(\"%d\\t\", p->data);\n\t\tp = p->next;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n循环单链表（带头结点）//循环单链表-带头结点\n #include &lt;stdio.h>\n#include &lt;stdlib.h>\ntypedef struct LNode &#123;\n\tint data;\n\tstruct LNode* next;\n&#125;LNode, * LinkList;\n// 单链表的建立\nLinkList List_TailInsert(LinkList&amp; L) &#123;// 尾插法\n\tL=(LNode*)malloc(sizeof(LNode));\n\tL->data=-1;\n\tLNode* temp=L;\n\n\tint x;\n\tscanf(\"%d\",&amp;x);\n\twhile(x!=0)&#123;\n\t\tLNode* s= (LNode*)malloc(sizeof(LNode));\n\t\ts->data=x;\n\t\ttemp->next=s;\n\t\ttemp=s;\n\t\tscanf(\"%d\",&amp;x);\n\t&#125;\n\ttemp->next=L;\n\treturn L;\n&#125;\n\nint Length(LinkList&amp; l)&#123;\n\tLNode* s=l;\n\tint res=0;\n\twhile(s->next!=l)&#123;\n\t\tres++;\n\t\ts=s->next;\n\t&#125;\n\treturn res;\n&#125;\n// 按位序i查找结点，头结点的位序是0，1是第一个节点\nLNode* GetElem(LinkList&amp; L, int i) &#123;\n\tint length=Length(L);\n\tif(i&lt;0||L==NULL||i>length) return NULL;\n\tLNode* s=L;\n\tint j=0;\n\twhile(j&lt;i)&#123;\n\t\ts=s->next;\n\t\tj++;\n\t&#125;\n\treturn s;\n&#125;\n// 按值e查找结点\nLNode* LocateElem(LinkList&amp; L, int e) &#123;\n\tLNode* s=L;\n\twhile(s->next!=NULL)&#123;\n\t\tif(s->data==e)&#123;\n\t\t\treturn s;\n\t\t&#125;\n\t\ts=s->next;\n\t&#125;\n\treturn NULL;\n&#125;\n// 在位序i的位置插入结点操作\nbool ListInsert(LinkList&amp; L, int i, int e) &#123;\n\tint length=Length(L);\n\tif(i&lt;=0||i>length+1) return false;\n\tLNode* pre=GetElem(L,i-1);\n\tLNode* s= (LNode*)malloc(sizeof(LNode));\n\ts->data=e;\n\ts->next=pre->next;\n\tpre->next=s;\n\treturn true;\n&#125;\n// 在位序i的位置删除结点操作\nbool ListDelete(LinkList&amp; L, int i, int&amp; e) &#123;\n\tint length=Length(L);\n\tif(i&lt;=0||i>length||L==NULL) return false;\n\tLNode* pre=GetElem(L,i-1);\n\tLNode*temp=pre->next;\n\te=temp->data;\n\tpre->next=temp->next;\n\tfree(temp);\n&#125;\n// 链表输出-任意一个结点都可以循环遍历整个链表\nvoid PrintLinkList(LinkList&amp; startNode) &#123;//\n\tLNode* s=startNode;\n\tdo&#123;\n\n\t\tprintf(\"%d\\t\",s->data);\n\t\ts=s->next;\n\t&#125;while(s!=startNode);\n\tprintf(\"\\n\");\n&#125;\n\n带头结点的循环双链表#include &lt;stdio.h>\n#include &lt;stdlib.h>\ntypedef struct LNode &#123;\n\tint data;\n\tstruct LNode* next;// 下一个\n\tstruct LNode* prior;// 上一个\n&#125;LNode, * LinkList;\n// 循环双链表的建立\nLinkList List_TailInsert(LinkList&amp; L) &#123;// 尾插法\n\tL=(LNode*)malloc(sizeof(LNode));\n\tL->data=-1;\n\tLNode* temp=L;\n\tint x;\n\tscanf(\"%d\",&amp;x);\n\twhile(x!=0)&#123;\n\t\tLNode* s=(LNode*)malloc(sizeof(LNode));\n\t\ts->data=x;\n\t\ttemp->next=s;\n\t\ts->prior=temp;\n\t\ttemp=s;\n\t\tscanf(\"%d\",&amp;x);\n\t&#125;\n\ttemp->next=L;\n\tL->prior=temp;\n\treturn L;\n&#125;\n//长度\nint Length(LinkList&amp; l)&#123;\n\tLNode* s=l;\n\tint res=0;\n\twhile(s->next!=l)&#123;\n\t\tres++;\n\t\ts=s->next;\n\t&#125;\n\n\treturn res;\n\n&#125;\n// 按位序i查找结点，头结点的位序是0，1是第一个节点\nLNode* GetElem(LinkList&amp; L, int i) &#123;\n\tint length=Length(L);\n\tif(i&lt;=0||i>length) return NULL;\n\tint j=0;\n\tLNode* s=L;\n\twhile(j&lt;i)&#123;\n\t\ts=s->next;\n\t\tj++;\n\t&#125;\n\treturn s;\n&#125;\n// 按值e查找结点\nLNode* LocateElem(LinkList&amp; L, int e) &#123;\n\tLNode* s=L;\n\twhile(s!=L)&#123;\n\t\tif(s->data==e)&#123;\n\t\t\treturn s;\n\t\t&#125;\n\t\ts=s->next;\n\t&#125;\n\treturn NULL;\n&#125;\n// 在位序i的位置插入结点操作\nbool ListInsert(LinkList&amp; L, int i, int e) &#123;\n\tint length=Length(L);\n\tif(i&lt;=0||i>length+1)&#123;\n\t\treturn false;\n\t&#125;\n\tLNode* pre=GetElem(L,i-1);\n\tLNode* nxt=pre->next;\n\tLNode* s=(LNode*)malloc(sizeof(LNode));\n\ts->data=e;\n\ts->next=nxt;\n\tpre->next=s;\n\tnxt->prior=s;\n\ts->prior=pre;\n\treturn true;\n&#125;\n// 在位序i的位置删除结点操作\nbool ListDelete(LinkList&amp; L, int i, int&amp; e) &#123;\n\tint length=Length(L);\n\tif(i&lt;=0||i>length)&#123;\n\t\treturn false;\n\t&#125;\n\tLNode* pre=GetElem(L,i-1);\n\tLNode* temp=pre->next;\n\tLNode* nxt=temp->next;\n\tpre->next=nxt;\n\tnxt->prior=pre;\n\tfree(temp);\n\treturn true;\n&#125;\n// 链表输出-任意一个结点都可以循环遍历整个链表\nvoid PrintLinkList(LinkList&amp; startNode) &#123;\n\tLNode* s=startNode;\n\tdo&#123;\n\t\tif(s->data!=-1)&#123;\n\t\t\tprintf(\"%d\\t\",s->data);\n\t\t&#125;\n\t\ts=s->next;\n\t&#125;while(s!=startNode);\n\tprintf(\"\\n\");\n&#125;\n\n栈实现链式实现链表头部插入删除\n#include &lt;stdio.h>\n#include &lt;stdlib.h>\n// 不带头结点\ntypedef struct Linknode &#123;\n\tint data;\n\tstruct Linknode* next;\n&#125;Linknode, * LiStack;\n// 在链栈首处插入一个节点\nbool InsertNextNode(LiStack&amp; L, int e) &#123;\n\tLinknode* s = (Linknode*)malloc(sizeof(Linknode));\n\ts->data = e;\n\tif (L == NULL) &#123;\n\t\tL = s;\t// 第一个节点\n\t\ts->next = NULL;// 下一个初始化为空 ！！！\n\t&#125;\n\telse &#123;\n\t\ts->next = L;\n\t\tL = s;\n\t&#125;\n\treturn true;\n&#125;\n// 头插法建立链表\nLiStack LiStack_HeadInsert(LiStack&amp; L) &#123;\n\tint x = 1;\n\tscanf(\"%d\", &amp;x);\n\twhile (x != 0) &#123;\n\t\tInsertNextNode(L, x);\n\t\tscanf(\"%d\", &amp;x);\n\t&#125;\n\treturn L;\n&#125;\n// 入栈\nbool Push(LiStack&amp; L, int e) &#123;\n\treturn InsertNextNode(L, e);\n&#125;\n// 出栈\nbool Pop(LiStack&amp; L, int&amp; e) &#123;\n\tif (L == NULL) &#123;\n\t\treturn false;\n\t&#125;\n\tLinknode* s = L;\n\te = s->data;\n\tL = s->next;\n\tfree(s);\n\treturn true;\n&#125;\n// 是否为空\nbool LiStackEmpty(LiStack&amp; L) &#123;\n\tif (L == NULL) &#123;\n\t\treturn true;\n\t&#125;\n\treturn false;\n&#125;\n// 打印\nvoid PrintLiStack(LiStack&amp; L) &#123;\n\tif (L == NULL) &#123;\n\t\treturn;\n\t&#125;\n\tLinknode* p = L;\n\twhile (p != NULL) &#123;\n\t\tprintf(\"%d\\t\", p->data);\n\t\tp = p->next;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n数组实现#include &lt;stdio.h>\n#define MaxSize 50\n\ntypedef struct &#123;\n\tint data[MaxSize];\n\tint top; //指向下一个要填入数据的位置\n&#125; SqStack;\n// 初始化\nvoid InitStack(SqStack&amp; stack) &#123;\n\tstack.top = 0;\n&#125;\n// 是否为空\nbool StackEmpty(SqStack&amp; stack) &#123;\n\tif (stack.top == 0) &#123;\n\t\treturn true;\n\t&#125;\n\treturn false;\n&#125;\n// 入栈\nbool Push(SqStack&amp; stack, int e) &#123;\n\tif (stack.top == MaxSize) &#123;// 是否满了\n\t\treturn false;\n\t&#125;\n\tstack.data[stack.top++] = e;\n\treturn true;\n&#125;\n// 出栈\nbool Pop(SqStack&amp; stack, int&amp; e) &#123;\n\tif (stack.top == 0) &#123;\n\t\treturn false;\n\t&#125;\n\te = stack.data[stack.top-1];\n\tstack.top--;\n\treturn true;\n&#125;\n// 获取栈顶\nbool GetTop(SqStack&amp; stack, int&amp; e) &#123;\n\tif (stack.top == 0) &#123;\n\t\treturn false;\n\t&#125;\n\te = stack.data[stack.top - 1];\n\treturn true;\n&#125;\n// 遍历\nvoid PrintStack(SqStack&amp; stack) &#123;\n\tfor (int i = 0; i &lt; stack.top; i++) &#123;\n\t\tprintf(\"%d\\t\", stack.data[i]);\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n栈的应用括号匹配// 括号匹配\nint MatchKuohao(SqStack&amp; L, const char* s, int len) &#123;\n\tchar c = 0;\n//\tprintf(\"%d\\n\",len);\n\tfor (int i = 0; i &lt; len; i++) &#123;\n\t\tc = s[i];\n\t\t// 1.判断是否为左括号 是就入栈\n\t\tif (c == '(' || c == '&#123;' || c == '[') &#123;\n\t\t\tPush(L, c);\n\t\t&#125;\n\t\telse &#123;\n\t\t\t// 2.是右括号，取出栈顶括号与之匹配\n\t\t\tif (StackEmpty(L)) &#123; // 不存在左括号与之匹配，代表失败\n\t\t\t\treturn 1;\n\t\t\t&#125;\n\t\t\tPop(L, c);\n\t\t\t// 判断是否匹配\n\t\t\tif (s[i] == ')' &amp;&amp; c != '('||s[i] == '&#125;' &amp;&amp; c != '&#123;'||s[i] == ']' &amp;&amp; c != '[') &#123;\n\t\t\t\treturn 2;\n\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t// 3.在判断栈是否有左括号未匹配的\n\tif (!StackEmpty(L)) &#123;\n\t\treturn 3;\n\t&#125;\n\treturn 0;\n&#125;\nint main()\n&#123;\n\tSqStack L;\n\t// 括号匹配开始\n\tconst char* s = \"(&#123;()&#125;)\";\n\tint b = MatchKuohao(L, s, strlen(s));\n\tprintf(\"%s\", s);\n\tif (b == 0) &#123;\n\t\tprintf(\"括号匹配成功\\n\");\n\t&#125;\n\telse if (b == 1) &#123;\n\t\tprintf(\"括号匹配失败, 右括号多了\\n\");\n\t&#125;\n\telse if (b == 2) &#123;\n\t\tprintf(\"括号匹配失败，左右括号不匹配\\n\");\n\t&#125;\n\telse if (b == 3) &#123;\n\t\tprintf(\"括号匹配失败， 左括号多了\\n\");\n\t&#125;\n\treturn 0;\n&#125;\n\n中缀转后缀及计算#include &lt;string.h&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\nusing namespace std;\n\n&#x2F;&#x2F; 对比运算符(当c1 &gt;&#x3D; c2 返回1， 当 c1 &lt; c2 返回-1 ）\nint CompareCal(char c1, char c2) &#123;&#x2F;&#x2F; c1，c2 是运算符，假定只有+-*&#x2F;\n\tswitch (c1) &#123;\n\tcase &#39;+&#39;:case &#39;-&#39;:\n\t\tif (c2 &#x3D;&#x3D; &#39;*&#39; || c2 &#x3D;&#x3D; &#39;&#x2F;&#39;)&#x2F;&#x2F; “+ -”小于“* &#x2F;”\n\t\t\treturn -1;\n\t&#125;\n\treturn 1;&#x2F;&#x2F; 默认大于\n&#125;\nint Cal(int val1, char op, int val2) &#123;\n\tswitch (op) &#123;\n\tcase &#39;+&#39;:\n\t\treturn val1 + val2;\n\tcase &#39;-&#39;:\n\t\treturn val1 - val2;\n\tcase &#39;*&#39;:\n\t\treturn val1 * val2;\n\tcase &#39;&#x2F;&#39;:\n\t\treturn val1 &#x2F; val2;\n\t&#125;\n\treturn 0;\n&#125;\n&#x2F;&#x2F; 1.中缀转后缀表达式生成算法\nstring GenerateHou(stack&lt;char&gt;&amp; opstack, string&amp; s) &#123;\n\n\t&#x2F;&#x2F;存储后缀表达式\n\tstring hous;\n\t&#x2F;&#x2F;分别储存当前字符串的字符 、 运算符栈中的字符\n\tchar curc,zhanc;\n\n\tfor(int i&#x3D;0;i&lt;s.length();i++)&#123;\n\t\tcurc&#x3D;s[i];\n\n\t\t&#x2F;&#x2F;1.遇到操作数，直接将它输出\n\t\tif(isdigit(curc))&#123;\n\t\t\thous&#x3D;hous+curc;\n\t\t&#125;\n\t\t&#x2F;&#x2F;2.遇到（，直接push\n\t\telse if(curc&#x3D;&#x3D;&#39;(&#39;)&#123;\n\t\t\topstack.push(curc);\n\t\t&#125;\n\t\t&#x2F;&#x2F;遇到），栈元素弹出并输出，知道遇到左括号（左括号只弹出，不输出）\n\t\telse if(curc&#x3D;&#x3D;&#39;)&#39;)&#123;\n\t\t\tzhanc&#x3D;opstack.top();\n\t\t\topstack.pop();\n\t\t\twhile(zhanc!&#x3D;&#39;(&#39;)&#123;\n\t\t\t\thous&#x3D;hous+zhanc;\n\t\t\t\tzhanc&#x3D;opstack.top();\n\t\t\t\topstack.pop();\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F;其他运算符的情况\n\t\t&#x2F;&#x2F;如果栈为空，直接Push\n\t\t&#x2F;&#x2F;如果栈顶是(，直接push\n\t\t&#x2F;&#x2F;如果栈顶是运算符，判断优先级，优先级高或相同的pop并输出，直到遇到优先级低的，将curc入栈\n\t\telse&#123;\n\t\t\twhile(!opstack.empty())&#123;\n\t\t\t\tzhanc&#x3D;opstack.top();\n\t\t\t\tif(zhanc&#x3D;&#x3D;&#39;(&#39;)&#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\tif(CompareCal(zhanc,curc)&#x3D;&#x3D;1)&#123;\n\t\t\t\t\thous&#x3D;hous+zhanc;\n\t\t\t\t\topstack.pop();\n\t\t\t\t&#125;\n\t\t\t\telse&#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\topstack.push(curc);\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 把栈中剩下的放入后缀表达式中\n\twhile (!opstack.empty()) &#123;\n\t\tzhanc &#x3D; opstack.top();\n\t\topstack.pop();\n\t\thous &#x3D; hous + zhanc;\n\t&#125;\n\treturn hous;\n\n&#125;\n&#x2F;&#x2F; 2.后缀表达式计算\nint CalHou(stack&lt;int&gt;&amp; distack, string&amp; s) &#123;\n\tint left,right;\n\tint sum;\n\tchar curc;\n\tfor(int i&#x3D;0;i&lt;s.length();i++)&#123;\n\t\tcurc&#x3D;s[i];\n\t\tif(isdigit(curc))&#123;\n\t\t\tdistack.push(curc-&#39;0&#39;);&#x2F;&#x2F;转换成数字\n\t\t&#125;else&#123;\n\t\t\tleft&#x3D;distack.top();\n\t\t\tdistack.pop();\n\t\t\tright&#x3D;distack.top();\n\t\t\tdistack.pop();\n\t\t\tsum&#x3D;Cal(left,curc,right);\n\t\t\tdistack.push(sum);\n\t\t&#125;\n\t&#125;\n\treturn sum;\n&#125;\n\n队列数组实现#include &lt;stdio.h>\n#include &lt;stdlib.h>\n#define MaxSize 5\ntypedef struct &#123;\n\tint data[MaxSize];\n\tint front, rear;  //rear指向下一个要插入数据的位置\n&#125;SqQueue;\n// 初始化\nvoid InitQueue(SqQueue&amp; Q) &#123;\n\tQ.front= Q.rear=0;\n&#125;\n// 判断为空\nbool QueueEmpty(SqQueue&amp; Q) &#123;\n\treturn Q.rear=Q.front;\n&#125;\n// 入队 - 只能在队尾插入\nbool EnQueue(SqQueue&amp; Q, int e) &#123;\n\tif((Q.rear+1)%MaxSize==Q.front)&#123;  //判断是否为满，实际上浪费了一个存储空间\n\t\treturn false;\n\t&#125;\n\tQ.data[Q.rear]=e;\n\tQ.rear=(Q.rear+1)%MaxSize;\n\treturn true;\n&#125;\n// 出队 - 只能在队头出\nbool DeQueue(SqQueue&amp; Q, int&amp; e) &#123;\n\tif(Q.rear==Q.front)&#123;\n\t\treturn false;\n\t&#125;\n\te=Q.data[Q.front];\n\tQ.front=(Q.front+1)%MaxSize;\n\treturn true;\n&#125;\n// 读队头元素\nbool GetHead(SqQueue&amp; Q, int&amp; e) &#123;\n\tif(Q.rear==Q.front)&#123;\n\t\treturn false;\n\t&#125;\n\te=Q.data[Q.front];\n\treturn true;\n&#125;\nint GetSize(SqQueue&amp; Q) &#123;\n\treturn (Q.rear+MaxSize-Q.front)%MaxSize;\n&#125;\n// 打印\nvoid PrintSqQueue(SqQueue&amp; Q) &#123;\n\tif(Q.rear==Q.front)&#123;\n\t\treturn;\n\t&#125;\n\tfor(int i=Q.front;i!=Q.rear;)&#123;\n\t\tprintf(\"%d\\t\",Q.data[i]);\n\t\ti=(i+1)%MaxSize;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n链表实现#include &lt;stdio.h>\n#include &lt;stdlib.h>\n// 带头结点\ntypedef struct LinkNode &#123;\n\tint data;\n\tstruct LinkNode* next;\n&#125;LinkNode;\n\ntypedef struct &#123;\n\tLinkNode* front, * rear;\n&#125;LinkQueue;\n// 初始化\nvoid InitQueue(LinkQueue&amp; Q) &#123;\n\tLinkNode* s=(LinkNode*)malloc(sizeof(LinkNode));\n\tQ.front=Q.rear=s;\n\tQ.front->next=NULL;\n&#125;\n// 判断为空\nbool QueueEmpty(LinkQueue&amp; Q) &#123;\n\treturn Q.front->next==NULL;\n&#125;\n// 入队 - 只能在队尾插入\nbool EnQueue(LinkQueue&amp; Q, int e) &#123;\n\tLinkNode* s=(LinkNode*)malloc(sizeof(LinkNode));\n\ts->data=e;\n\tQ.rear->next=s;\n\ts->next=NULL;\n\tQ.rear=s;\n\treturn true;\n&#125;\n// 出队 - 只能在队头出\nbool DeQueue(LinkQueue&amp; Q, int&amp; e) &#123;\n\tif(QueueEmpty(Q)) return false;\n\tLinkNode* s=Q.front->next;\n\te=s->data;\n\tQ.front->next=s->next;\n\tif(s==Q.rear)&#123;\n\t\tQ.rear=Q.front;\n\t&#125;\n\tfree(s);\n\treturn true;\n&#125;\n// 读队头元素\nbool GetHead(LinkQueue&amp; Q, int&amp; e) &#123;\n\tif(QueueEmpty(Q)) return false;\n\tLinkNode* s=Q.front->next;\n\te=s->data;\n\treturn true;\n&#125;\nint GetSize(LinkQueue&amp; Q) &#123;\n\tint size=0;\n\tLinkNode* s=Q.front->next;\n\twhile(s!=NULL)&#123;\n\t\tsize++;\n\t\ts=s->next;\n\t&#125;\n\treturn size;\n&#125;\n// 打印\nvoid PrintLiStack(LinkQueue&amp; Q) &#123;\n\tLinkNode* s=Q.front->next;\n\twhile(s!=NULL)&#123;\n\t\tprintf(\"%d\\t\",s->data);\n\t\ts=s->next;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n串#include &lt;stdio.h>\n#include &lt;string.h>\n#define MAXLEN 255\nusing namespace std;\n\n//位序从0开始\ntypedef struct&#123;\n\tchar ch[MAXLEN];\n\tint length;\n&#125;SString;\n\n//将chars赋值给串\nbool StrAssign(SString&amp; T,char *chars)\n&#123;\n\tif(strlen(chars)>MAXLEN)\n\t\treturn false;\n\telse\n\t&#123;\n\t\tT.length=strlen(chars);\n\t\tfor(int i=0;i&lt;T.length;i++)&#123;\n\t\t\tT.ch[i]=*(chars+i);\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n&#125;\n\n//打印\nvoid print(SString T)&#123;\n\tfor(int i=0;i&lt;T.length;i++)&#123;\n\t\tprintf(\"%c\\t\",T.ch[i]);\n\t&#125;\n\tprintf(\"长度：%d\\n\",T.length);\n&#125;\n\n//将串s复制到串t\nbool StrCopy(SString&amp; T,SString S)\n&#123;\n\tint i;\n\tfor(i=0;i&lt;S.length;i++)\n\t\tT.ch[i]=S.ch[i];\n\treturn true;\n&#125;\n\n//判断是否为空\nbool StrEmpty(SString T)&#123;\n\treturn T.length>0?0:1;\n&#125;\n\n//清空\nbool ClearString(SString&amp; T)&#123;\n\tT.length=0;\n\treturn true;\n&#125;\n\n//串T由两个串连接起来\nbool Concat(SString&amp; T,char* s1,char*s2)&#123;\n\tif(strlen(s1)+strlen(s2)>MAXLEN)&#123;\n\t\treturn false;\n\t&#125;else&#123;\n\t\tT.length=strlen(s1)+strlen(s2);\n\t\tint i;\n\t\tfor(i=0;i&lt;strlen(s1);i++)&#123;\n\t\t\tT.ch[i]=*(s1+i);\n\t\t&#125;\n\t\tfor(int j=0;i&lt;T.length;i++)&#123;\n\t\t\tT.ch[i]=*(s2+j);\n\t\t\tj++;\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n\n&#125;\n\n//取子串\nbool SubString(SString &amp;Sub,SString S,int pos,int len)\n&#123;\n\tif(pos+len-1>S.length)&#123;\n\t\treturn false;\n\t&#125;else&#123;\n\t\tfor(int i=pos;i&lt;pos+len;i++)&#123;\n\t\t\tSub.ch[i-pos]=S.ch[i];\n\t\t&#125;\n\t\tSub.length=len;\n\t\treturn true;\n\t&#125;\n&#125;\n\n//比较操作\nint StrCompare(SString s,SString t)&#123;\n\tfor(int i=0;i&lt;s.length&amp;&amp;i&lt;t.length;i++)&#123;\n\t\tif(s.ch[i]!=t.ch[i])&#123;\n\t\t\treturn s.ch[i]-t.ch[i];\n\t\t&#125;\n\t&#125;\n\treturn s.length-t.length;\n&#125;\n\n//找到子串的位置\nint Index(SString s,SString t)&#123;\n\tint i=0;\n\tSString sub;\n\twhile(i&lt;=s.length-t.length)&#123;\n\t\tSubString(sub,s,i,t.length);\n\t\tif(StrCompare(sub,t)!=0)&#123;\n\t\t\ti++;\n\t\t&#125;else&#123;\n\t\t\treturn i;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\n\n//朴素匹配\nint PsIndex(SString t,SString s)&#123;\n\tint k=0;\n\tint i=0,j=0;\n\twhile(i&lt;t.length&amp;&amp;j&lt;s.length)&#123;\n\t\tif(t.ch[i]==s.ch[j])&#123;\n\t\t\ti++;\n\t\t\tj++;\n\t\t&#125;else&#123;\n\t\t\tk++;\n\t\t\ti=k;\n\t\t\tj=0;\n\t\t&#125;\n\t&#125;\n\tif(j=s.length)&#123;\n\t\treturn k;\n\t&#125;\n\telse&#123;\n\t\treturn -1;\n\t&#125;\n&#125;\n\nkmp 算法略。\n树二叉树基本操作数组实现#include &lt;stdio.h>\n#include &lt;cmath>\n\n#define TreeSize 99\n#define MaxSize 100\n/*\n以完全二叉树形式存储结点\ni的左孩子：2i\ni的右孩子：2i+1\ni的父节点：i/2 向下取整\ni所在的层次（深度）：log2 (n) + 1\n*/\nstruct TreeNode &#123;\n\tint value; \t\t// 节点中的数据元素\n\tbool isEmpty; \t// 结点是否为空\n&#125;;\n// 初始化\nvoid InitTreeNode(TreeNode(&amp;t)[MaxSize]) &#123;\n\tfor(int i=0;i&lt;=MaxSize;i++)&#123;\n\t\tt[i].isEmpty=true;\n\t&#125;\n&#125;\n// 位序i结点的左孩子\nTreeNode GetLeftC(TreeNode(&amp;t)[MaxSize], int i) &#123;\n\tint j=2*i;\n\tif(j&lt;1||j>MaxSize||t[j].isEmpty) return t[0];\n\treturn t[j];\n&#125;\n// 位序i结点的右孩子\nTreeNode GetRightC(TreeNode(&amp;t)[MaxSize], int i) &#123;\n\tint j=2*i+1;\n\tif(j&lt;1||j>MaxSize||t[j].isEmpty) return t[0];\n\treturn t[j];\n&#125;\n// 位序i结点的父结点\nTreeNode GetParentC(TreeNode(&amp;t)[MaxSize], int i) &#123;\n\tint j=i/2;\n\tif(j&lt;1||j>MaxSize||t[j].isEmpty) return t[0];\n\treturn t[j];\n&#125;\n// 位序i结点层次（深度）\nint GetDepth(TreeNode(&amp;t)[MaxSize], int i) &#123;\n\tif(i&lt;1||i>MaxSize) return 0;\n\tint j=log(i)/log(2)+1;\n\treturn j;\n&#125;\n// 在位序i的位置插入一个结点\nbool InsertTreeNode(TreeNode(&amp;t)[MaxSize], int i, int e) &#123;\n\tif(i&lt;1||i>MaxSize)&#123;\n\t\treturn false;\n\t&#125;\n\tTreeNode s;\n\ts.isEmpty=false;\n\ts.value=e;\n\tt[i]=s;\n\treturn true;\n&#125;\n// 删除在位序i的位置上的结点 - 要注意把他的左右孩子也删除\nbool DeleteTreeNode(TreeNode(&amp;t)[MaxSize], int i, int&amp; e) &#123;\n\tif(i&lt;1||i>MaxSize) return false;\n\n\tDeleteTreeNode(t,2*i,e);\n\tDeleteTreeNode(t,2*i+1,e);\n\n\te=t[i].value;\n\tt[i].isEmpty=true;\n\treturn true;\n&#125;\n// 顺序遍历\nvoid PrintTreeNodeOrder(TreeNode(&amp;t)[MaxSize]) &#123;\n\tfor(int i=1;i&lt;MaxSize;i++)&#123;\n\t\tif(!t[i].isEmpty)&#123;\n\t\t\tprintf(\"%d\\t\",t[i].value);\n\t\t&#125;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n// 遍历各个结点详细信息\nvoid PrintTreeNodeAll(TreeNode(&amp;t)[MaxSize], int maxn) &#123;\n\tTreeNode tn1, tn2, tn3;\n\tint depth;\n\tfor (int i = 1; i &lt; maxn; i++) &#123;\n\t\tif (t[i].isEmpty) &#123;\n\t\t\tprintf(\"%d结点为空\\n\", i);\n\t\t\tcontinue;\n\t\t&#125;\n\t\ttn1 = GetLeftC(t, i);\t// 左结点\n\t\ttn2 = GetRightC(t, i);  // 有结点\n\t\ttn3 = GetParentC(t, i); // 父亲结点\n\t\tif (!tn3.isEmpty) &#123;\n\t\t\tprintf(\"%d结点的父结点是：%d\\t\", i, tn3.value);\n\t\t&#125;\n\t\telse &#123;\n\t\t\tprintf(\"%d结点没有父结点 \\t\", i);\n\t\t&#125;\n\t\tif (!tn1.isEmpty) &#123;\n\t\t\tprintf(\"%d结点的左结点是：%d\\t\", i, tn1.value);\n\t\t&#125;\n\t\telse &#123;\n\t\t\tprintf(\"%d结点没有左结点 \\t\", i);\n\t\t&#125;\n\t\tif (!tn2.isEmpty) &#123;\n\t\t\tprintf(\"%d结点的右结点是：%d\\t\", i, tn2.value);\n\t\t&#125;\n\t\telse &#123;\n\t\t\tprintf(\"%d结点没有右结点 \\t\", i);\n\t\t&#125;\n\t\tdepth = GetDepth(t, i);\n\t\tprintf(\"%d结点的深度是%d\\n\", i, depth);\n\t&#125;\n&#125;\n\n链表实现#include &lt;stdio.h>\n#include &lt;stdlib.h>\n#include &lt;cmath>\n//三叉链表\ntypedef struct BiTNode &#123;\n\tint data; \t\t// 数据域\n\tstruct BiTNode* lchild, * rchild;// 左右孩子指针\n\tstruct BiTNode* parent;// 父亲结点\n&#125;BiTNode, * BiTree;\n// 插入根结点\nbool InsertRootNode(BiTree&amp; btree, int e) &#123;\n\tbtree=(BiTNode*)malloc(sizeof(BiTNode));\n\tbtree->data=e;\n\tbtree->lchild=NULL;\n\tbtree->rchild=NULL;\n\tbtree->parent=NULL;\n\treturn true;\n&#125;\n// 1.当前p结点的左孩子\nBiTNode* GetLeftC(BiTNode* p) &#123;\n\tif(p==NULL) return NULL;\n\treturn p->lchild;\n&#125;\n// 2.当前p结点的右孩子\nBiTNode* GetRightC(BiTNode* p) &#123;\n\tif(p==NULL) return NULL;\n\treturn p->rchild;\n&#125;\n// 3.当前p结点的父亲\nBiTNode* GetParent(BiTNode* p) &#123;\n\tif(p==NULL) return NULL;\n\treturn p->parent;\n&#125;\n// 当前结点c插入一个左结点\nbool InsertTreeLeftNode(BiTree&amp; c, int e) &#123;\n\tif(c==NULL) return false;\n\tBiTNode* s=(BiTree)malloc(sizeof(BiTree));\n\ts->data=e;\n\ts->parent=c;\n\ts->lchild=NULL;\n\ts->rchild=NULL;\n\tc->lchild=s;\n\treturn true;\n&#125;\n// 当前c结点插入一个右结点\nbool InsertTreeRightNode(BiTree&amp; c, int e) &#123;\n\tif(c==NULL) return false;\n\tBiTNode* s=(BiTree)malloc(sizeof(BiTree));\n\ts->data=e;\n\ts->parent=c;\n\ts->lchild=NULL;\n\ts->rchild=NULL;\n\tc->rchild=s;\n\treturn true;\n&#125;\n// 删除c节点 : 要删除c结点的左右结点，并且释放空间\nbool DeleteTreeNode(BiTree&amp; c) &#123;\n\tif(c==NULL) return false;\n\n\tif(c->lchild!=NULL)&#123;\n\t\tDeleteTreeNode(c->lchild);\n\t&#125;\n\tif(c->rchild!=NULL)&#123;\n\t\tDeleteTreeNode(c->rchild);\n\t&#125;\n\n\tif(c->parent!=NULL)&#123;\n\t\tBiTNode* s=c->parent;\n\t\tif(c==s->lchild)&#123;\n\t\t\ts->lchild=NULL;\n\t\t&#125;else&#123;\n\t\t\ts->rchild=NULL;\n\t\t&#125;\n\t&#125;\n\n\tfree(c);\n\treturn true;\n&#125;\n// 判断二叉树是否为空\nbool Empty(BiTree&amp; root) &#123;\n\treturn root==NULL?true:false;\n&#125;\n// 辅助方法：中序遍历\nvoid InOrder(BiTree p) &#123;// 不能引用类型\n\tif (p != NULL) &#123;\n\t\tInOrder(p->lchild);\n\t\tprintf(\"%d  \", p->data);\n\t\tInOrder(p->rchild);\n\t&#125;\n&#125;\n\n遍历// 本小节重点------------------------------------------------\n// 前序遍历\nvoid PreOrder(BiTree p) &#123;// 不能引用类型\n\tif (p != NULL) &#123;\n\t\tprintf(\"%d  \", p->data);\n\t\tPreOrder(p->lchild);\n\t\tPreOrder(p->rchild);\n\t&#125;\n&#125;\n// 中序遍历\nvoid InOrder(BiTree p) &#123;// 不能引用类型\n\tif (p != NULL) &#123;\n\t\tInOrder(p->lchild);\n\t\tprintf(\"%d  \", p->data);\n\t\tInOrder(p->rchild);\n\t&#125;\n&#125;\n// 后序遍历\nvoid PostOrder(BiTree p) &#123;// 不能引用类型\n\tif (p != NULL) &#123;\n\t\tPostOrder(p->lchild);\n\t\tPostOrder(p->rchild);\n\t\tprintf(\"%d  \", p->data);\n\t&#125;\n&#125;\n// 层次遍历\nvoid CenCi(BiTree&amp; root) &#123;\n\tqueue&lt;BiTNode*> que;\n\tque.push(root);\n\tBiTNode* p;\n\twhile(!que.empty())&#123;\n\t\tp=que.front();\n\t\tque.pop();\n\t\tprintf(\"%d \",p->data);\n\t\tif(p->lchild!=NULL)&#123;\n\t\t\tque.push(p->lchild);\n\t\t&#125;\n\t\tif(p->rchild!=NULL)&#123;\n\t\t\tque.push(p->rchild);\n\t\t&#125;\n\t&#125;\n&#125;\n// 难点------------------------------------------------\n// 非递归遍历\nvoid PreOrderDiTui(BiTree&amp; root) &#123;// 前序\n\tstack&lt;BiTNode*> bistack;\n\tBiTNode* p=root;\n\twhile(p!=NULL||!bistack.empty())&#123;\n\t\tif(p!=NULL)&#123;\n\t\t\tbistack.push(p);\n\t\t\tprintf(\"%d \",p->data);\n\t\t\tp=p->lchild;\n\t\t&#125;else&#123;\n\t\t\tp=bistack.top();\n\t\t\tbistack.pop();\n\t\t\tp=p->rchild;\n\t\t&#125;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\nvoid InOrderDiTui(BiTree&amp; root) &#123;// 中序\n\tstack&lt;BiTNode*> bistack;\n\tBiTNode* p = root;\n\twhile (p != NULL || !bistack.empty()) &#123;\n\t\tif (p != NULL) &#123;\n\t\t\tbistack.push(p);\n\t\t\tp = p->lchild;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tp = bistack.top();\n\t\t\tbistack.pop();\n\t\t\tprintf(\"%d  \", p->data);\n\t\t\tp = p->rchild;\n\t\t&#125;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\nvoid PostOrderDiTui(BiTree&amp; root) &#123;// 后序\n\tstack&lt;BiTNode*> bistack;\n\tBiTNode* p = root;\n\tBiTNode* lastp = NULL;// 上一个访问的结点 ,关键点！，用来判断是否右子树返回\n\twhile(p!=NULL||!bistack.empty())&#123;\n\t\tif(p!=NULL)&#123;\n\t\t\tbistack.push(p);\n\t\t\tp=p->lchild;\n\t\t&#125;else&#123;\n\n\t\t\tp=bistack.top();\n\n\t\t\t//此时有两种可能\n\t\t\t//1.访问完左子树再次回到父节点(需继续访问右子树，如果右子树为空就不访问了)\n\t\t\t//2.访问完右子树或右子树为空（直接pop并访问）\n\t\t\tif(p->rchild==NULL||lastp==p->rchild)&#123;\n\t\t\t\tbistack.pop();\n\t\t\t\tprintf(\"%d \",p->data);\n\t\t\t\tlastp=p;\n\t\t\t\tp=NULL;\n\t\t\t&#125;else&#123;\n\t\t\t\tp=p->rchild;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n由遍历序列构建二叉树必须要有中序遍历序列才可以。\n线索二叉树\n（错误：rtag&#x3D;1）\n\n\n\n\n\n树的存储结构双亲表示法\n孩子表示法\n孩子兄弟表示法\n\n\n二叉排序树（BTS）\n#include &lt;stdio.h>\n#include &lt;stdlib.h>\n//二叉排序树\n\ntypedef struct BSTNode\n&#123;\n\tint data;\n\tBSTNode *lchild;  //左孩子\n\tBSTNode *rchild;  //右孩子\n&#125;BSTNode, *BSTree;\n\nBSTNode* Search(BSTree t, int key)&#123;\n\twhile(t!=NULL&amp;&amp;key!=t->data)&#123; //如果查找到空，或查找到对应值，退出循环\n\t\tif(key&lt;t->data)&#123;\n\t\t\tt=t->lchild;\n\t\t&#125;else&#123;\n\t\t\tt=t->rchild;\n\t\t&#125;\n\t&#125;\n\treturn t;\n&#125;\n\nvoid InOderTraverse(BSTree bst)   //中序递归遍历二叉树\n&#123;\n\tif (NULL != bst)\n\t&#123;\n\t\tInOderTraverse(bst->lchild);\n\t\tprintf(\"%d \", bst->data);\n\t\tInOderTraverse(bst->rchild);\n\t&#125;\n&#125;\n\n//插入节点\nbool Insert(BSTree &amp;t, int key)\n&#123;\n\tif (NULL == t)  //空树\n\t&#123;\n\t\tt=(BSTree)malloc(sizeof(BSTNode));\n\t\tt->data=key;\n\t\tt->lchild=NULL;\n\t\tt->rchild=NULL;\n\t\treturn true;\n\t&#125;else if(t->data==key) &#123;  //已经存在，插入失败\n\t\tprintf(\"\\nThe node(%d) already exists.\\n\", key);\n\t\treturn false;\n\t&#125;else if(t->data&lt;key)&#123;\n\t\treturn Insert(t->rchild,key);\n\t&#125;else&#123;\n\t\treturn Insert(t->lchild,key);\n\t&#125;\n&#125;\n\n//创建二叉排序树\nvoid create(BSTree &amp;t,int str[],int length)&#123;\n\tfor(int i=0;i&lt;length;i++)&#123;\n\t\tInsert(t,str[i]);\n\t&#125;\n&#125;\n\n/*\n删除分三种情况：\n(1)被删除的节点无孩子，说明该节点是叶子节点，直接删\n(2)被删除的节点只有左孩子或者右孩子，直接删，并将其左孩子或者右孩子放在被删节点的位置\n(3)被删除的节点既有右孩子又有右孩子\n1.找到左子树的最右节点（没有右孩子），来替代删除节点，再由节点的左孩子替代它 ----此处用这种方法\n2.找到右子树的最左节点（没有左孩子），来替代删除节点，再由节点的右孩子替代它\n*/\nbool Delete(BSTree&amp; T, int key)\n&#123;\n\tif (NULL == T||Search(T,key)==NULL)\n\t&#123;\n\t\treturn false;  //空树或者差找不到直接报错\n\t&#125;\n\n\tBSTNode* p=Search(T,key);\n\tBSTNode* q;\n\tBSTNode* s;\n\n\tif ( p->lchild==NULL &amp;&amp;  p->rchild !=NULL)  //无左孩子,有右孩子\n\t&#123;\n\t\tq = p->rchild;\n\t\tp->data = q->data;\n\t\tp->rchild = q->rchild;\n\t\tp->lchild = q->lchild;\n\t\tfree(q);\n\t&#125;\n\telse if (NULL == p->rchild &amp;&amp; NULL != p->lchild)  //无右孩子,有左孩子\n\t&#123;\n\t\tq = p->lchild;\n\t\tp->data = q->data;\n\t\tp->rchild = q->rchild;\n\t\tp->lchild = q->lchild;\n\t\tfree(q);\n\t&#125;\n\telse if (NULL != p->rchild &amp;&amp; NULL != p->lchild) //既有左孩子，又有右孩子\n\t&#123;\n\t\tq = p;\n\t\ts = p->lchild;   //找左孩子的最右孩子--s\n\t\t\twhile (s->rchild)\n\t\t\t&#123;\n\t\t\t\tq = s;    //q存储s的父节点\n\t\t\t\ts = s->rchild;\n\t\t\t&#125;\n\t\t\tp->data = s->data;\n\n\t\t\tif (q != p)\n\t\t\t&#123;\n\t\t\t\tq->rchild = s->lchild;//用s的左孩子替代s\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tq->lchild = s->lchild; //如果p的左孩子没有右孩子，也就是说p的左孩子就是左子树的最右结点\n\t\t\t&#125;\n\t\t\tfree(s);\n\t\t&#125;\n\t\telse  //只有一个根节点，且要删除根节点\n\t\t&#123;\n\t\t\tfree(T);\n\t\t&#125;\n\t\treturn true;\n&#125;\n\n平衡二叉树（AVL）\n二叉排序树的平均查找长度（ASL）：\n\n最好情况：O（log2n）——平衡二叉树\n最坏：O（n）\n\n\nLL\n\n\nRR 同理，左旋\n\nLR 先左旋后右旋\n\n\nRL 先右旋后左旋\n\n\n哈夫曼树（最优树）路径长度：路径上经过的边个数\n树的带权路径长度（WPL）：树中所有叶子结点的带权路径长度之和\nWPL 最小的树就是哈夫曼树\n\n\n并查集（Disjoint Set）用森林中的不同树表示互不相关的集合。\n查：查询某个节点所在树的根节点\n并：将两个树合并，也就是将两个集合合并为一个集合 时间复杂度 O（1）\n并查集更适合用双亲表示法实现：合并时改变 parent 数据即可\n初始化：将所有 s[]设为-1\n\n注：Find 操作中，树的高度会影响时间复杂度\n怎么尽可能减小树的高度呢？\n\n经过优化，Find 的时间复杂度最差 O（log2n）\n终极优化：\n\n\n","slug":"数据结构1","date":"2023-03-12T16:00:00.000Z","categories_index":"","tags_index":"基础知识","author_index":"Serena"},{"id":"7a897380fbf2b52c7fdc533d413e1985","title":"MyBatis","content":"MyBatismysql 密码：yang\n\n配置数据库路径加入 mysql 和 mybatis 依赖\n连接池配置\n# DataSourceProperties\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/community?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Hongkong\nspring.datasource.username=root\nspring.datasource.password=yang\nspring.datasource.type=com.zaxxer.hikari.HikariDataSource\nspring.datasource.hikari.maximum-pool-size=15\nspring.datasource.hikari.minimum-idle=5\nspring.datasource.hikari.idle-timeout=30000\n\nmybatis 配置，用 entity 类封装表里的数据\n# MybatisProperties\nmybatis.mapper-locations=classpath:mapper/*.xml\nmybatis.type-aliases-package=com.nowcoder.community.entity\nmybatis.configuration.useGeneratedKeys=true\nmybatis.configuration.mapUnderscoreToCamelCase=true\n\nmapper 使用方法\n实体类：get set 函数\ndao 类：设置 mapper 接口，定义对实体类进行操作的函数注解@Mapperinsert 和 update 返回 int，表示修改行数select 返回 user 实体类\nresources&#x2F;mapper 中：mapper.xml 写函数对应的 sql 操作mybatis 官网查找对应模板id 即对应的函数\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.nowcoder.community.dao.UserMapper\">\n\n    &lt;sql id=\"insertFields\">\n        username, password, salt, email, type, status, activation_code, header_url, create_time\n    &lt;/sql>\n\n    &lt;sql id=\"selectFields\">\n        id, username, password, salt, email, type, status, activation_code, header_url, create_time\n    &lt;/sql>\n\n    &lt;select id=\"selectById\" resultType=\"User\">\n        select &lt;include refid=\"selectFields\">&lt;/include>\n        from user\n        where id = #&#123;id&#125;\n    &lt;/select>\n\n    &lt;insert id=\"insertUser\" parameterType=\"User\" keyProperty=\"id\">\n        insert into user (&lt;include refid=\"insertFields\">&lt;/include>)\n        values(#&#123;username&#125;, #&#123;password&#125;, #&#123;salt&#125;, #&#123;email&#125;, #&#123;type&#125;, #&#123;status&#125;, #&#123;activationCode&#125;, #&#123;headerUrl&#125;, #&#123;createTime&#125;)\n    &lt;/insert>\n\n    &lt;update id=\"updateStatus\">\n        update user set status = #&#123;status&#125; where id = #&#123;id&#125;\n    &lt;/update>\n&lt;/mapper>\n","slug":"MyBatis","date":"2023-03-02T16:00:00.000Z","categories_index":"","tags_index":"Spring","author_index":"Serena"},{"id":"cd53cdbf97b8f99c953dd3eda45eed25","title":"SpringMVC","content":"Spring MVC\n\n\n项目结构\n\ncontroller 控制层\ndao 数据访问层\nservice 业务层\nmodel 是自带结构\n模板文件放在 templates\n\nmodel 和模板文件通过模板引擎 Thymeleaf 形成 HTML\nrequest&amp;response@RequestMapping(\"/http\")\npublic void http(HttpServletRequest request, HttpServletResponse response)&#123;\n    //获取请求数据\n    System.out.println(request.getMethod());\n    System.out.println(request.getServletPath());\n    Enumeration&lt;String> enumeration=request.getHeaderNames();\n    while (enumeration.hasMoreElements())&#123;\n        String name=enumeration.nextElement();\n        String value=request.getHeader(name);\n        System.out.println(name+\":\"+value);\n    &#125;\n    System.out.println(request.getParameter(\"code\"));\n\n    //返回响应数据\n    response.setContentType(\"text/html;charset=utf-8\");\n    try(\n            PrintWriter writer=response.getWriter();\n            ) &#123;\n        //输出流\n        writer.write(\"&lt;h1>学院论坛&lt;/h1>\");\n    &#125; catch (IOException e) &#123;\n        throw new RuntimeException(e);\n    &#125;\n    System.out.println();\n&#125;\n\n浏览器显示：学院论坛\n\n命令行显示：\nGET&#x2F;alpha&#x2F;httphost:localhost:8080connection:keep-alivesec-ch-ua:”Chromium”;v&#x3D;”110”, “Not A(Brand”;v&#x3D;”24”, “Microsoft Edge”;v&#x3D;”110”sec-ch-ua-mobile:?0sec-ch-ua-platform:”Windows”upgrade-insecure-requests:1user-agent:Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;110.0.0.0 Safari&#x2F;537.36 Edg&#x2F;110.0.1587.57accept:text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,&#x2F;;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.7sec-fetch-site:nonesec-fetch-mode:navigatesec-fetch-user:?1sec-fetch-dest:documentaccept-encoding:gzip, deflate, braccept-language:zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6cookie:Hm_lvt_eefa59dfd5fb29fcc57a8b2437ad5ab1&#x3D;1654502733,1654736646; Hm_lvt_e4027971a230b210f4671f485b33846a&#x3D;1677157216123\nGET 请求的两种传参方式// /student?current=1&amp;limit=20\n@RequestMapping(path=\"/students\",method = RequestMethod.GET)\n@ResponseBody\npublic String getStudent(\n        @RequestParam(name=\"current\",required=false,defaultValue=\"1\")int current,\n        @RequestParam(name=\"limit\",required=false,defaultValue=\"10\")int limit)&#123;\n    System.out.println(current);\n    System.out.println(limit);\n    return \"some students\";\n&#125;\n\n// /student/123\n@RequestMapping(path = \"/student/&#123;id&#125;\",method = RequestMethod.GET)\n@ResponseBody\npublic String getStudent(@PathVariable(\"id\") int id)&#123;\n    System.out.println(id);\n    return \"a student\";\n&#125;\n\nPOST 请求传参在静态页面写一个表单\n&lt;form action=\"/community/alpha/student\" method=\"post\">\n  &lt;p>姓名：&lt;input name=\"name\" tupe=\"text\" />&lt;/p>\n  &lt;p>年龄：&lt;input name=\"age\" type=\"text\" />&lt;/p>\n  &lt;p>\n    &lt;input type=\"submit\" value=\"保存\" />\n  &lt;/p>\n&lt;/form>\n\n//POST请求\n@RequestMapping(path = \"/student\",method = RequestMethod.POST)\n@ResponseBody\npublic String saveStudent(String name,int age)&#123;\n    System.out.println(name);\n    System.out.println(age);\n    return \"success\";\n&#125;\n\n变量名称相同会自动获取（get 同理）\n\n\n\n\n\n\n\n\n\nget 用来获取参数，post 用来传参（其实 get 也能传参，但是数据都在路径上，且路径长度有限）\n向浏览器响应动态 html\n使用 ModelAndView\n\n//响应html\n@RequestMapping(path = \"/teacher\",method = RequestMethod.GET)\npublic ModelAndView getTeacher()&#123;\n    ModelAndView mav=new ModelAndView();\n    mav.addObject(\"name\",\"张三\");\n    mav.addObject(\"age\",\"30\");\n    mav.setViewName(\"/demo/view\");\n    return mav;\n&#125;\n\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n  &lt;head>\n    &lt;meta charset=\"UTF-8\" />\n    &lt;title>Teacher&lt;/title>\n  &lt;/head>\n  &lt;body>\n    &lt;p th:text=\"$&#123;name&#125;\">&lt;/p>\n    &lt;p th:text=\"$&#123;age&#125;\">&lt;/p>\n  &lt;/body>\n&lt;/html>\n\n\n使用 Model，返回 view 的 path，交给 dispatcherServlet\n\n@RequestMapping(path = \"/school\" ,method=RequestMethod.GET)\npublic String getSchool(Model model)&#123;\n  model.addAttribute(\"name\",\"北大\");\n  model.addAttribute(\"age\",\"80\"); return \"/demo/view\";\n&#125;\n\n向浏览器响应 json 文件通常用于异步请求，比如注册时昵称是否被占用\nDispatcherServelt 检测到 map 会自动转换成 json 文件\n@RequestMapping(path = \"/emp\",method = RequestMethod.GET)\n@ResponseBody\npublic Map&lt;String,Object> getEmp()&#123;\n    Map&lt;String,Object> emp=new HashMap&lt;>();\n    emp.put(\"name\",\"张三\");\n    emp.put(\"age\",\"23\");\n    emp.put(\"salary\",\"8000\");\n    return emp;\n&#125;\n\n浏览器显示：\n&#123; \"name\": \"张三\", \"salary\": \"8000\", \"age\": \"23\" &#125;\n","slug":"SpringMVC","date":"2023-03-02T16:00:00.000Z","categories_index":"","tags_index":"Spring","author_index":"Serena"},{"id":"946249c65165e1a3d66f50e0cb6e89e7","title":"Spring","content":"Spring Boot 核心作用\n起步依赖\n\n​ 使用Spring Initializr进行项目配置：aop thymeleaf web devtools\n\n自动配置\n\n端点监控\n\n\nSpring IoC\nInversion of Control -控制反转，是一种面向对象编程的设计思想\n\nDependency Injection -依赖注入，IoC 的实现方式\n\nIoC Container -IoC 容器，实现依赖注入的关键，本质是一个工厂\n\n\n\nSpring&amp;Bean配置类底层自动创建 spring 容器\nApplicationContext 即 Spring 容器，这个接口继承于 BeanFactor（Spring 容器的顶层接口）\n@SpringBootApplication\npublic class CommunityApplication &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tSpringApplication.run(CommunityApplication.class, args);\n\t&#125;\n&#125;\n\n@SpringBootApplication 表明这是一个配置类进入 SpringBootApplication.java\n@SpringBootConfiguration\n@EnableAutoConfiguration //自动配置\n@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;) //扫描配置类所在包以及子包下的bean\n\nbean 内有相应注解才会被扫描\n@Controller //请求\nService //业务\nRepository //数据库访问\nComponent //通用\n\n均由 Component 实现\ngetBean()一个类想实现 Spring 容器，要实现 ApplicationContextAware 接口\n@SpringBootTest\n@ContextConfiguration(classes = CommunityApplication.class) //设置配置类\nclass CommunityApplicationTests implements ApplicationContextAware &#123;\n\tprivate ApplicationContext applicationContext;\n\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;\n\t\tthis.applicationContext=applicationContext;\n\t&#125;\n\n\t@Test\n\tpublic void testApplicationContext()&#123;\n\t\tSystem.out.println(applicationContext);\n\t&#125;\n&#125;\n\nAlphaDao alphadao&#x3D;applicationContext.getBean(AlphaDao.class); &#x2F;&#x2F;按类型获取bean\n\n如果 Bean 冲突了怎么办？在要获取的 Bean 加入\n\n\n\n\n\n\n\n\n\n@Primary\n或者给 Bean 起名字\n@Repository(\"AlphaHibernate\")\n\nalphadao=applicationContext.getBean(\"AlphaHibernate\",AlphaDao.class);\n\nBean 管理public  AlphaService()&#123;\n    System.out.println(\"实例化AlphaService\");\n&#125;\n\n@PostConstruct\npublic void init()&#123;\n    System.out.println(\"初始化AlphaService\");\n&#125;\n\n@PreDestroy\npublic void destory()&#123;\n    System.out.println(\"销毁AlphaService\");\n&#125;\n\n默认 Bean 是单例模式的，想要同样的类出现多个不同的 bean，需要注释\n@Scope(\"prototype\") //默认singleton\n\n如果想要导入第三方的 bean 怎么办？\n创建一个 config 文件\n@Configuration\npublic class AlphaConfig &#123;\n    @Bean\n    public SimpleDateFormat simpleDateFormat()&#123;\n        return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    &#125;\n&#125;\n\n更简单的方法？-&gt;依赖注入将 AlphaDao 注入 alphaDao\n@Autowired\n\tprivate AlphaDao alphaDao;\n\n指定注入的 bean\n@Autowired\n@Qualifier(&quot;AlphaHibernate&quot;)\nprivate AlphaDao alphaDao;\n\n请求的执行过程\n","slug":"Spring","date":"2023-02-28T16:00:00.000Z","categories_index":"","tags_index":"Spring","author_index":"Serena"},{"id":"cf26a6b1cbc6c769e4f860791ff7a888","title":"maven配置","content":"maven 命令使用maven 作用：构建项目，管理 jar 包技术文档：Maven – Maven in 5 Minutes (apache.org)\n配置中心仓库，镜像仓库\n查看版本\nmvn -version\n\n以 maven 自带模板建立一个项目（没有 class）\nmvn archetype:generate -DgroupId&#x3D;com.mycompany.app -DartifactId&#x3D;my-app -DarchetypeArtifactId&#x3D;maven-archetype-quickstart -DarchetypeVersion&#x3D;1.4 -DinteractiveMode&#x3D;false\n\n编译项目（出现 classes）\nmvn compile\n\n清空项目并测试（test-classes）\nmvn clean test\n\n\n找不到 org.junit，通过重新安装解决。。。\n依赖中出现了\n\n\n仍然不知道为什么\n","slug":"maven配置","date":"2023-02-28T08:36:26.000Z","categories_index":"","tags_index":"环境配置","author_index":"Serena"},{"id":"46426c79fe8370cebf57bb63c792f570","title":"hello","content":"欢迎来到我的个人博客这是一个使用 Hexo Aurora 建立的静态博客文档：https://aurora.tridiamond.tech/zh/guide/范例：https://abyssaler.github.io/Markdown 语法：https://markdown.com.cn/basic-syntax/\n评论留言功能敬请期待","slug":"hello","date":"2023-02-22T16:00:00.000Z","categories_index":"","tags_index":"介绍","author_index":"Serena"}]