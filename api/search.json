[{"id":"18745307628dd554480cf2320609e50d","title":"yolov5网络","content":"说在前面：感谢这位大佬Bubbliiiing 的博客_CSDN 博客-神经网络学习小记录,睿智的目标检测,有趣的数据结构算法领域博主以下是一些学习笔记\nYOLOv5YOLOv5 针对不同大小（ n , s , m , l , x ）的网络整体架构都是一样的，只不过会在每个子模块中采用不同的深度和宽度，分别应对 yaml 文件中的 depth_multiple 和 width_multiple 参数 Yolov5s 网络是 Yolov5 系列中深度最小，特征图的宽度最小的网络。后面的 3 种都是在此基础上不断加深，不断加宽。\nyolov5 的改进\n使用了 Focus 网络结构，具体操作是在一张图片中每隔一个像素拿到一个值，压缩宽高，扩张通道数，宽高信息就集中到了通道信息,输入通道扩充了四倍。但是 YOLOv5 在 v6.0 版本后相比之前版本有一个很小的改动，把网络的第一层（原来是 Focus 模块）换成了一个 6x6 大小的卷积层。两者在理论上其实等价的，但是对于现有的一些 GPU 设备（以及相应的优化算法）使用 6x6 大小的卷积层比使用 Focus 模块更加高效。\nMosaic 数据增强采用了 4 张图片，随机缩放、随机裁剪、随机排布的方式进行拼接，对于小目标的检测效果是不错的。丰富数据集：随机使用 4 张图片，随机缩放，再随机分布进行拼接，丰富了检测数据集，尤其是随机缩放增加了小目标。减少 GPU：可能会有人说，随机缩放，普通的数据增强也可以做，但作者考虑到很多人可能只有一个 GPU，因此 Mosaic 增强训练时，可以直接计算 4 张图片的数据，使得 Mini-batch 大小并不需要很大，一个 GPU 就可以达到比较好的效果。\n\n\n\n\n\n\n\n\nMini-batch：梯度下降需要对所有样本进行处理过后然后走一步，如果样本规模大会导致效率低，这种梯度下降叫 full batch。 为了提高效率，将样本分成等量子集， 这些子集就称为 minibatch。假如我们用 for 循环遍历 1000 个子集， 针对子集做一次梯度下降，然后更新参数 w 和 b 的值。接着到下一个子集继续梯度下降。 遍历完所有的 mini batch 之后相当于在梯度下降中做了 1000 次迭代，将遍历一次所有样本的行为叫做一个 epoch。在 Mini-batch 下的梯度下降中做的事情跟 full batch 一样，只不过我们训练的数据是一个个的子集。 这样在一个 epoch 中就能进行 1000 次的梯度下降（走的步数多），而在 full batch 中只有一次，这提高了算法的运行速度。\n\n\n网络结构Backbone：YoloV5 的主干特征提取网络，根据它的结构以及之前 Yolo 主干的叫法，我一般叫它 CSPDarknet，输入的图片首先会在 CSPDarknet 里面进行特征提取，提取到的特征可以被称作特征层，是输入图片的特征集合。在主干部分，我们获取了三个特征层进行下一步网络的构建，这三个特征层我称它为有 效特征层。FPN（特征金字塔网络）：YoloV5 的加强特征提取网络，在主干部分获得的三个有效特征层会在这一部分进行特征融合，特征融合的目的是结合不同尺度的特征信息。在 FPN 部分，已经获得的有效特征层被用于继续提取特征。在 YoloV5 里依然使用到了 PAN 的结构，我们不仅会对特征进行上采样实现特征融合，还会对特征 再次进行下采样实现特征融合。Yolo Head：YoloV5 的分类器与回归器，通过 CSPDarknet 和 FPN，我们已经可以获得三个加强过的有效特征层。每一个特征层都有宽、高和通道数，此时我们可以将特征图看作一个又一个特征点的集合，每一个特征 点都有通道数个特征。Yolo Head 实际上所做的工作就是对特征点进行判断，判断特征点是否有物体与其对应。与以前版本的 Yolo 一样，YoloV5 所用的解耦头是一起的，也就是分类和回归在一个 1X1 卷积里实现。因此，整个 YoloV5 网络所作的工作就是 特征提取-特征加强-预测特征点对应的物体情况。\nBackbone卷积+标准化+激活函数进行高和宽的压缩和通道数的扩张使用了 SiLU 激活函数，SiLU 是 Sigmoid 和 ReLU 的改进版。SiLU 具备无上界有下界、平滑、非单调的特性。SiLU 在深层模型上的效果优于 ReLU。可以看做是平滑的 ReLU 激活函数。\nCSPlayer残差残差块：使用了残差网络 Residual，残差卷积可以分为两个部分，主干部分是一次 1X1 的卷积和一次 3X3 的卷积；残差边部分不做任何处理，直接将主干的输入与输出结合。残差网络的作用：\n\n堆叠网络后网络难以收敛，而且梯度爆炸（梯度消失）在一开始就阻碍网络的收敛，让网络难以训练，得到适当的参数。\n理论上来讲，增加网络的层数，网络可以进行更加复杂的特征提取，可以取得更好的结果。但是实验发现深度网络出现了退化问题，因为在适当的深度模型上添加更多的层会导致了更高的训练误差，从而使其下降。残差网络解决了上述问题：对于这整个堆叠结构，当输入 x 时，它学习到的特征记为 H（x），因此我们希望他学习到的残差为 F（x）&#x3D; H（x）- x；那么我们最初学习到的特征就是 H（x）&#x3D; F（x）+ x。假如本来我们要优化的目标是 H（x）&#x3D;F（x）+ x，但通过这个结构就把优化的目标有 H（x）转化成 H（x）-x。这时候就不是把上面几层训练到一个等价映射，而是将其逼近于 0，这样训练的难度比训练一个等价映射 应该下降多了。CSPnet：将原来的残差块的堆叠进行了一个拆分，拆成左右两部分：主干部分继续进行原来的残差块的堆叠；另一部分则像一个残差边一样，经过少量处理直接连接到最后（concat）。因此可以认为CSP 中存在一个大的残差边。\n\n最后利用卷积进行通道整合最后一个 CSPlayer 没有残差边\n\n\n\n\n\n\n\n\n\n作者在论文阐述了 CSP 结构的优点:\n更丰富的梯度组合，同时减少计算量\n（1）加强 CNN 的学习能力；（2）减少计算瓶颈，现在的网络大多计算代价昂贵，不利于工业的落地；（3）减少内存消耗。\nSPP通过不同池化核大小的最大池化进行特征提取，提高网络的感受野。在 YoloV4 中，SPP 是用在 FPN 里面的，在 YoloV5 中，SPP 模块被用在了主干特征提取网络中。实现局部特征和全局特征的融合\nNeck\nFPN 是自顶向下，将高层的强语义特征传递下来，对整个金字塔进行增强，不过只增强了语义信息，对定位信息没有传递。PAN 就是针对这一点，在 FPN 的后面添加一个自底向上的金字塔，对 FPN 补充，将低层的强定位特征传递上去，又被称之为“双塔战术”。\nConcat 是通道数的增加（堆叠）；add 是特征图相加，通道数不变\nyolohead\n利用 FPN 特征金字塔，我们可以获得三个加强特征，这三个加强特征的 shape 分别为(20,20,1024(40,40,512)、(80,80,256)，然后我们利用这三个 shape 的特征层传入 Yolo Head 获得预测结果。\n对于每一个特征层，我们可以获得利用一个卷积调整通道数，最终的通道数和需要区分的种类个数相关，在 YoloV5 里，每一个特征层上每一个特征点存在 3 个先验框。\n\n4+1：中心点的 x,y；预测框的宽高，是否有对应物体，属于哪一类别\n预测得到最终的预测结果后还要进行得分排序与非极大抑制筛选。\n得分筛选就是筛选出得分满足 confidence 置信度的预测框。\n非极大抑制就是筛选出一定区域内属于同一种类得分最大的框。\n得分筛选与非极大抑制的过程可以概括如下：\n1、找出该图片中得分大于门限函数的框。在进行重合框筛选前就进行得分的筛选可以大幅度减少框的数 量。\n2、对种类进行循环，非极大抑制的作用是筛选出一定区域内属于同一种类得分最大的框，对种类进行循环\n可以帮助我们对每一个类分别进行非极大抑制。\n3、根据得分对该种类进行从大到小排序。\n4、每次取出得分最大的框，计算其与其它所有预测框的重合程度，重合程度过大的则剔除。\n得分筛选与非极大抑制后的结果就可以用于绘制预测框了。\n其他一维卷积核的降维和升维\n\n","slug":"yolov5网络","date":"2023-04-17T15:53:25.817Z","categories_index":"","tags_index":"深度学习","author_index":"Serena"},{"id":"9b3e5c64d9c6600c826b6e407be811c5","title":"数据结构（1）","content":"数据结构最近跟着 b 站上的王道课程重新学了一遍数据结构，以下是 c 语言版的实现,因为时间来不及有一些知识点没有敲代码带有主函数的代码可以看我的 github https://github.com/YangYue2022/DataStructure\n线性表顺序表#顺序表的静态存储\n#include &lt;stdio.h>\n#define MaxSize 10 // 定义最大长度\n\ntypedef struct &#123;\n\tint data[MaxSize];\n\tint length;\n&#125;SqList;\n// 初始化\nvoid InitList(SqList&amp; L) &#123;\n\tL.length = 0;\n&#125;\n// 根据位序i插入e元素\nbool ListInsert(SqList&amp; L, int i, int e) &#123;\n\tif (i &lt; 1 || i > L.length + 1) &#123; // 是否合法\n\t\treturn false;\n\t&#125;\n\tfor (int j = L.length; j >= i; j--) &#123;// 先向后移动\n\t\tL.data[j] = L.data[j - 1];\n\t&#125;\n\tL.data[i - 1] = e;// 再i-1位置放置e\n\tL.length++; // 长度+1\n\treturn true;\n&#125;\n// 根据位序i删除元素，返回删除的元素值e\nbool ListDelete(SqList&amp; L, int i, int&amp; e) &#123;\n\tif (i &lt; 1 || i > L.length) &#123;\n\t\treturn false;\n\t&#125;\n\te = L.data[i - 1];\n\tfor (int j = i; j &lt; L.length; j++) &#123;// 删除的位置后的元素往前移动\n\t\tL.data[j - 1] = L.data[j];\n\t&#125;\n\tL.length--;\n\treturn true;\n&#125;\n// 按位序i查找元素，返回值\nint GetElem(SqList&amp; L, int i) &#123;\n\tif (i &lt; 1 || i > L.length) &#123;\n\t\treturn 0;\n\t&#125;\n\treturn L.data[i - 1];\n&#125;\n// 按值e查找元素，返回位序\nint LocateElem(SqList&amp; L, int e) &#123;\n\tfor (int i = 0; i &lt; L.length; i++) &#123;\n\t\tif (e == L.data[i]) &#123;\n\t\t\treturn i + 1;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n// 遍历顺序表元素\nvoid PrintList(SqList&amp; L) &#123;\n\tfor (int i = 0; i &lt; L.length; i++) &#123;\n\t\tprintf(\"%d\\t\", L.data[i]);\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n链表不带头节点的单链表#include &lt;stdio.h>\n#include &lt;stdlib.h>\ntypedef struct node\n&#123;\n\tint data;\n\tstruct node* next;\n&#125; LNode, * LinkList;\n// 链表建立\nLinkList List_TailInsert(LinkList&amp; L) &#123;// 尾插法\n\tL=(LNode*)malloc(sizeof(LNode*));\n\tLNode *s=L,*t=NULL;\n\tL->next=NULL;\n\tint x;\n\tscanf(\"%d\",&amp;x);\n\twhile(x!=0)&#123;\n\t\t//s是新节点，t是尾节点\n\t\ts->data=x;\n\t\tif(t!=NULL)&#123;\n\t\t\tt->next=s;\n\t\t&#125;\n\t\tt=s;\n\t\tscanf(\"%d\",&amp;x);\n\t\ts=(LNode*)malloc(sizeof(LNode*));\n\t&#125;\n\tt->next=NULL;\n\treturn L;\n&#125;\n// 按位序i查找结点，1是第一个节点\nLNode* GetElem(LinkList&amp; L, int i) &#123;\n\tif (i &lt;= 0) &#123;\n\t\treturn NULL;\n\t&#125;\n\tint j = 1;\t\t\t\t\t// // 注意：不带头结点从1开始，首元结点的位序为1\n\tLNode* p = L;\t\t\t\t// 头结点开始\n\twhile (p != NULL &amp;&amp; j &lt; i) &#123;\t// 依次寻找\n\t\tp = p->next;\n\t\tj++;\n\t&#125;\n\treturn p;\n\n&#125;\n// 在位序i的位置插入结点操作\nbool ListInsert(LinkList&amp; L, int i, int e) &#123;\n\tif(i&lt;1) return false;\n\telse if(i==1)&#123; //如果在表头插入节点\n\t\tLNode* s=(LNode*)malloc(sizeof(LNode*));\n\t\ts->data=e;\n\t\ts->next=L->next;\n\t\tL=s;\n\n\t&#125;\n\telse&#123;\n\t\tLNode* s=GetElem(L,i-1);\n\t\tLNode* p=(LNode*)malloc(sizeof(LNode*));\n\t\tp->data=e;\n\t\tp->next=s->next;\n\t\ts->next=p;\n\n\t&#125;\n\treturn true;\n\n&#125;\n// 在位序i的位置删除结点操作\nbool ListDelete(LinkList&amp; L, int i, int&amp; e) &#123;\n\n\tif(i&lt;1) return false;\n\n\t//删除第一个节点\n\tif(i==1)&#123;\n\t\tLNode* temp=L;\n\t\tL=L->next;\n\t\tfree(temp);\n\t&#125;\n\n\t//删除后面的节点\n\tLNode* temp= GetElem(L,i-1);\n\tif(temp==NULL) return false;\n\tLNode*q=temp->next;\n\ttemp->next=q->next;\n\tfree(q);\n\treturn true;\n\n&#125;\n// 求表长\nint Length(LinkList&amp; L) &#123;\n\tint res=0;\n\tfor(LNode* i=L;i!=NULL;i=i->next)&#123;\n\t\tres++;\n\t&#125;\n\treturn res;\n&#125;\n// 链表输出\nvoid PrintLinkList(LinkList&amp; L) &#123;\n\tLNode* p = L;\n\twhile (p != NULL) &#123;\n\t\tprintf(\"%d\\t\", p->data);\n\t\tp = p->next;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n带头结点的单链表#include &lt;stdio.h>\n#include &lt;stdlib.h>\ntypedef struct LNode &#123;\n\tint data;\n\tstruct LNode* next;\n&#125;LNode,* LinkList;\n// 单链表的建立\nLNode* List_HeadInsert(LinkList&amp; l) &#123;// 头插法，建立逆序单链表\n\tl=(LNode*)malloc(sizeof(LNode));\n\tLNode* s;\n\tint x;\n\tl->next=NULL;\n\tscanf(\"%d\",&amp;x);\n\twhile(x!=0)&#123;\n\t\ts=(LNode*)malloc(sizeof(LNode));\n\t\ts->data=x;\n\t\ts->next=l->next;\n\t\tl->next=s;\n\t\tscanf(\"%d\",&amp;x);\n\t&#125;\n\treturn l;\n&#125;\nLNode* List_TailInsert(LinkList&amp; l) &#123;// 尾插法\n\tl=(LNode*)malloc(sizeof(LNode));\n\tl->next=NULL;\n\tLNode* s;\n\tLNode* temp=l;\n\tint x;\n\tscanf(\"%d\",&amp;x);\n\twhile(x!=0)&#123;\n\t\ts=(LNode*)malloc(sizeof(LNode));\n\t\ts->data=x;\n\t\ts->next=NULL;\n\t\ttemp->next=s;\n\t\ttemp=s;\n\t\tscanf(\"%d\",&amp;x);\n\t&#125;\n\ttemp->next=NULL;\n\treturn l;\n&#125;\n// 按位序i查找结点，头结点的位序是0，1是第一个节点\nLNode* GetElem(LNode* l, int i) &#123;\n\tif(i&lt;0) return NULL;\n\tLNode* s=l;\n\tint j=0;\n\twhile(j&lt;i&amp;&amp;s!=NULL)&#123;\n\t\tj++;\n\t\ts=s->next;\n\t&#125;\n\treturn s;\n&#125;\n// 按值e查找结点\nLNode* LocateElem(LNode* l, int e) &#123;\n\tfor(LNode* s=l->next;s!=NULL;s=s->next)&#123;\n\t\tif(s->data==e)&#123;\n\t\t\treturn s;\n\t\t&#125;\n\t&#125;\n\treturn NULL;\n&#125;\n// 后插操作：在结点p后插入新节点-方法1\nbool InsertNextNode(LNode* p, int e) &#123;\n\tif(p==NULL) return false;\n\tLNode* s=(LNode*)malloc(sizeof(LNode));\n\ts->data=e;\n\ts->next=p->next;\n\tp->next=s;\n\treturn true;\n&#125;\n// 前插操作：在结点p之前插入元素e-方法2\nbool InsertPriorNode(LNode* p, int e) &#123;\n\tif(p==NULL) return false;\n\tLNode* s=(LNode*)malloc(sizeof(LNode));\n\ts->next=p->next;\n\tp->next=s;\n\ts->data=p->data;\n\tp->data=e;\n\treturn true;\n&#125;\n// 在位序i的位置插入结点操作\nbool ListInsert(LNode* l, int i, int e) &#123;\n\tLNode* s=GetElem(l,i-1);\n\tInsertNextNode(s,e);\n&#125;\n// 在位序i的位置插入结点操作\nbool ListInsertBefore(LNode* l, int i, int e) &#123;\n\tLNode* s=GetElem(l,i);\n\tInsertPriorNode(s,e);\n&#125;\n// 在位序i的位置删除结点操作-方法1\nbool ListDelete(LNode* l, int i, int&amp; e) &#123;\n\tLNode* s=GetElem(l,i-1);\n\tif(s==NULL) return false;\n\tLNode* q=s->next;\n\ts->next=q->next;\n\te=q->data;\n\tfree(q);\n\treturn true;\n&#125;\n//  删除指定结点p, 不通过前驱节点操作，用交换数据那样删除，但是注意最后一个节点不能这样删除-方法2\nbool DeleteZhidingLNode(LNode* p) &#123;\n\tif(p==NULL||p->next==NULL) return false;\n\tLNode* s=p->next;\n\tp->data=s->data;\n\tp->next=s->next;\n\tfree(s);\n\treturn true;\n&#125;\n// 在位序i的位置删除结点操作\nbool ListDeleteZhiding(LNode* l, int i, int&amp; e) &#123;\n\n\tLNode* s=GetElem(l,i);\n\tif(s==NULL) return false;\n\te=s->data;\n\tDeleteZhidingLNode(s);\n\treturn true;\n&#125;\n// 求表长\nint Length(LNode* l) &#123;\n\tint i=0;\n\tfor(LNode* s=l;s->next!=NULL;s=s->next)&#123;\n\t\ti++;\n\t&#125;\n\treturn i;\n&#125;\n// 链表输出\nvoid PrintLinkList(LinkList&amp; l) &#123;\n\tprintf(\"开始打印\");\n\tLNode* p = l;\n\twhile (p->next != NULL) &#123;\n\t\tp = p->next;\n\t\tprintf(\"%d\\t\", p->data);// 放后面因为头结点是没有值的\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n带头结点的双链表#include &lt;stdio.h>\n#include &lt;stdlib.h>\ntypedef struct LNode &#123;\n\tint data;\n\tstruct LNode* next;// 下一个\n\tstruct LNode* prior;// 上一个\n&#125;LNode, * LinkList;\n// 双链表的建立\nLinkList List_TailInsert(LinkList&amp; l) &#123;// 尾插法\n\tl=(LNode*)malloc(sizeof(LNode));\n\tl->prior=NULL;\n\tLNode*temp=l;\n\tint x;\n\tscanf(\"%d\",&amp;x);\n\twhile(x!=0)&#123;\n\t\tLNode*s=(LNode*)malloc(sizeof(LNode));\n\t\ts->data=x;\n\t\ts->prior=temp;\n\t\ttemp->next=s;\n\t\ttemp=s;\n\t\tscanf(\"%d\",&amp;x);\n\t&#125;\n\ttemp->next=NULL;\n\treturn l;\n&#125;\n// 按位序i查找结点，头结点的位序是0，1是第一个节点\nLNode* GetElem(LinkList&amp; L, int i) &#123;\n\tLNode* s=L;\n\tint j=0;\n\twhile(j&lt;i&amp;&amp;s!=NULL)&#123;\n\t\ts=s->next;\n\t\tj++;\n\t&#125;\n\treturn s;\n&#125;\n// 按值e查找结点\nLNode* LocateElem(LinkList&amp; L, int e) &#123;\n\tLNode* s=L;\n\twhile(s!=NULL)&#123;\n\t\tif(s->data==e)&#123;\n\t\t\treturn s;\n\t\t&#125;\n\t\ts=s->next;\n\t&#125;\n\treturn s;\n&#125;\n//求表长\nint Length(LinkList&amp; L) &#123;\n\tint res=0;\n\tfor(LNode* i=L->next;i!=NULL;i=i->next)&#123;\n\t\tres++;\n\t&#125;\n\treturn res;\n&#125;\n\n// 在位序i的位置插入结点操作\nbool ListInsert(LinkList&amp; L, int i, int e) &#123;\n\tint length=Length(L);\n\tif(i&lt;1||i>length+1) return false;\n\n\n\t\tLNode* s=(LNode*)malloc(sizeof(LNode));\n\t\ts->data=e;\n\t\tLNode* pre=GetElem(L,i-1);\n\n\t\tLNode* next=pre->next;\n\t\tpre->next=s;\n\t\ts->prior=pre;\n\t\ts->next=next;\n\t\tif(next!=NULL)&#123;\n\t\t\tnext->prior=s;\n\t\t&#125;\n\t\treturn true;\n&#125;\n// 在位序i的位置删除结点操作\nbool ListDelete(LinkList&amp; L, int i, int&amp; e) &#123;\n\tint length=Length(L);\n\tif(i&lt;1||i>length) return false;\n\tLNode* temp=GetElem(L,i);\n\tLNode* pre=temp->prior;\n\tLNode* next=temp->next;\n\te=temp->data;\n\tpre->next=next;\n\tif(next!=NULL)&#123;\n\t\tnext->prior=pre;\n\t&#125;\n\treturn true;\n&#125;\n// 链表输出\nvoid PrintLinkList(LinkList&amp; L) &#123;\n\tLNode* p = L->next;\n\twhile (p != NULL) &#123;\n\n\t\tprintf(\"%d\\t\", p->data);\n\t\tp = p->next;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n循环单链表（带头结点）//循环单链表-带头结点\n #include &lt;stdio.h>\n#include &lt;stdlib.h>\ntypedef struct LNode &#123;\n\tint data;\n\tstruct LNode* next;\n&#125;LNode, * LinkList;\n// 单链表的建立\nLinkList List_TailInsert(LinkList&amp; L) &#123;// 尾插法\n\tL=(LNode*)malloc(sizeof(LNode));\n\tL->data=-1;\n\tLNode* temp=L;\n\n\tint x;\n\tscanf(\"%d\",&amp;x);\n\twhile(x!=0)&#123;\n\t\tLNode* s= (LNode*)malloc(sizeof(LNode));\n\t\ts->data=x;\n\t\ttemp->next=s;\n\t\ttemp=s;\n\t\tscanf(\"%d\",&amp;x);\n\t&#125;\n\ttemp->next=L;\n\treturn L;\n&#125;\n\nint Length(LinkList&amp; l)&#123;\n\tLNode* s=l;\n\tint res=0;\n\twhile(s->next!=l)&#123;\n\t\tres++;\n\t\ts=s->next;\n\t&#125;\n\treturn res;\n&#125;\n// 按位序i查找结点，头结点的位序是0，1是第一个节点\nLNode* GetElem(LinkList&amp; L, int i) &#123;\n\tint length=Length(L);\n\tif(i&lt;0||L==NULL||i>length) return NULL;\n\tLNode* s=L;\n\tint j=0;\n\twhile(j&lt;i)&#123;\n\t\ts=s->next;\n\t\tj++;\n\t&#125;\n\treturn s;\n&#125;\n// 按值e查找结点\nLNode* LocateElem(LinkList&amp; L, int e) &#123;\n\tLNode* s=L;\n\twhile(s->next!=NULL)&#123;\n\t\tif(s->data==e)&#123;\n\t\t\treturn s;\n\t\t&#125;\n\t\ts=s->next;\n\t&#125;\n\treturn NULL;\n&#125;\n// 在位序i的位置插入结点操作\nbool ListInsert(LinkList&amp; L, int i, int e) &#123;\n\tint length=Length(L);\n\tif(i&lt;=0||i>length+1) return false;\n\tLNode* pre=GetElem(L,i-1);\n\tLNode* s= (LNode*)malloc(sizeof(LNode));\n\ts->data=e;\n\ts->next=pre->next;\n\tpre->next=s;\n\treturn true;\n&#125;\n// 在位序i的位置删除结点操作\nbool ListDelete(LinkList&amp; L, int i, int&amp; e) &#123;\n\tint length=Length(L);\n\tif(i&lt;=0||i>length||L==NULL) return false;\n\tLNode* pre=GetElem(L,i-1);\n\tLNode*temp=pre->next;\n\te=temp->data;\n\tpre->next=temp->next;\n\tfree(temp);\n&#125;\n// 链表输出-任意一个结点都可以循环遍历整个链表\nvoid PrintLinkList(LinkList&amp; startNode) &#123;//\n\tLNode* s=startNode;\n\tdo&#123;\n\n\t\tprintf(\"%d\\t\",s->data);\n\t\ts=s->next;\n\t&#125;while(s!=startNode);\n\tprintf(\"\\n\");\n&#125;\n\n带头结点的循环双链表#include &lt;stdio.h>\n#include &lt;stdlib.h>\ntypedef struct LNode &#123;\n\tint data;\n\tstruct LNode* next;// 下一个\n\tstruct LNode* prior;// 上一个\n&#125;LNode, * LinkList;\n// 循环双链表的建立\nLinkList List_TailInsert(LinkList&amp; L) &#123;// 尾插法\n\tL=(LNode*)malloc(sizeof(LNode));\n\tL->data=-1;\n\tLNode* temp=L;\n\tint x;\n\tscanf(\"%d\",&amp;x);\n\twhile(x!=0)&#123;\n\t\tLNode* s=(LNode*)malloc(sizeof(LNode));\n\t\ts->data=x;\n\t\ttemp->next=s;\n\t\ts->prior=temp;\n\t\ttemp=s;\n\t\tscanf(\"%d\",&amp;x);\n\t&#125;\n\ttemp->next=L;\n\tL->prior=temp;\n\treturn L;\n&#125;\n//长度\nint Length(LinkList&amp; l)&#123;\n\tLNode* s=l;\n\tint res=0;\n\twhile(s->next!=l)&#123;\n\t\tres++;\n\t\ts=s->next;\n\t&#125;\n\n\treturn res;\n\n&#125;\n// 按位序i查找结点，头结点的位序是0，1是第一个节点\nLNode* GetElem(LinkList&amp; L, int i) &#123;\n\tint length=Length(L);\n\tif(i&lt;=0||i>length) return NULL;\n\tint j=0;\n\tLNode* s=L;\n\twhile(j&lt;i)&#123;\n\t\ts=s->next;\n\t\tj++;\n\t&#125;\n\treturn s;\n&#125;\n// 按值e查找结点\nLNode* LocateElem(LinkList&amp; L, int e) &#123;\n\tLNode* s=L;\n\twhile(s!=L)&#123;\n\t\tif(s->data==e)&#123;\n\t\t\treturn s;\n\t\t&#125;\n\t\ts=s->next;\n\t&#125;\n\treturn NULL;\n&#125;\n// 在位序i的位置插入结点操作\nbool ListInsert(LinkList&amp; L, int i, int e) &#123;\n\tint length=Length(L);\n\tif(i&lt;=0||i>length+1)&#123;\n\t\treturn false;\n\t&#125;\n\tLNode* pre=GetElem(L,i-1);\n\tLNode* nxt=pre->next;\n\tLNode* s=(LNode*)malloc(sizeof(LNode));\n\ts->data=e;\n\ts->next=nxt;\n\tpre->next=s;\n\tnxt->prior=s;\n\ts->prior=pre;\n\treturn true;\n&#125;\n// 在位序i的位置删除结点操作\nbool ListDelete(LinkList&amp; L, int i, int&amp; e) &#123;\n\tint length=Length(L);\n\tif(i&lt;=0||i>length)&#123;\n\t\treturn false;\n\t&#125;\n\tLNode* pre=GetElem(L,i-1);\n\tLNode* temp=pre->next;\n\tLNode* nxt=temp->next;\n\tpre->next=nxt;\n\tnxt->prior=pre;\n\tfree(temp);\n\treturn true;\n&#125;\n// 链表输出-任意一个结点都可以循环遍历整个链表\nvoid PrintLinkList(LinkList&amp; startNode) &#123;\n\tLNode* s=startNode;\n\tdo&#123;\n\t\tif(s->data!=-1)&#123;\n\t\t\tprintf(\"%d\\t\",s->data);\n\t\t&#125;\n\t\ts=s->next;\n\t&#125;while(s!=startNode);\n\tprintf(\"\\n\");\n&#125;\n\n栈实现链式实现链表头部插入删除\n#include &lt;stdio.h>\n#include &lt;stdlib.h>\n// 不带头结点\ntypedef struct Linknode &#123;\n\tint data;\n\tstruct Linknode* next;\n&#125;Linknode, * LiStack;\n// 在链栈首处插入一个节点\nbool InsertNextNode(LiStack&amp; L, int e) &#123;\n\tLinknode* s = (Linknode*)malloc(sizeof(Linknode));\n\ts->data = e;\n\tif (L == NULL) &#123;\n\t\tL = s;\t// 第一个节点\n\t\ts->next = NULL;// 下一个初始化为空 ！！！\n\t&#125;\n\telse &#123;\n\t\ts->next = L;\n\t\tL = s;\n\t&#125;\n\treturn true;\n&#125;\n// 头插法建立链表\nLiStack LiStack_HeadInsert(LiStack&amp; L) &#123;\n\tint x = 1;\n\tscanf(\"%d\", &amp;x);\n\twhile (x != 0) &#123;\n\t\tInsertNextNode(L, x);\n\t\tscanf(\"%d\", &amp;x);\n\t&#125;\n\treturn L;\n&#125;\n// 入栈\nbool Push(LiStack&amp; L, int e) &#123;\n\treturn InsertNextNode(L, e);\n&#125;\n// 出栈\nbool Pop(LiStack&amp; L, int&amp; e) &#123;\n\tif (L == NULL) &#123;\n\t\treturn false;\n\t&#125;\n\tLinknode* s = L;\n\te = s->data;\n\tL = s->next;\n\tfree(s);\n\treturn true;\n&#125;\n// 是否为空\nbool LiStackEmpty(LiStack&amp; L) &#123;\n\tif (L == NULL) &#123;\n\t\treturn true;\n\t&#125;\n\treturn false;\n&#125;\n// 打印\nvoid PrintLiStack(LiStack&amp; L) &#123;\n\tif (L == NULL) &#123;\n\t\treturn;\n\t&#125;\n\tLinknode* p = L;\n\twhile (p != NULL) &#123;\n\t\tprintf(\"%d\\t\", p->data);\n\t\tp = p->next;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n数组实现#include &lt;stdio.h>\n#define MaxSize 50\n\ntypedef struct &#123;\n\tint data[MaxSize];\n\tint top; //指向下一个要填入数据的位置\n&#125; SqStack;\n// 初始化\nvoid InitStack(SqStack&amp; stack) &#123;\n\tstack.top = 0;\n&#125;\n// 是否为空\nbool StackEmpty(SqStack&amp; stack) &#123;\n\tif (stack.top == 0) &#123;\n\t\treturn true;\n\t&#125;\n\treturn false;\n&#125;\n// 入栈\nbool Push(SqStack&amp; stack, int e) &#123;\n\tif (stack.top == MaxSize) &#123;// 是否满了\n\t\treturn false;\n\t&#125;\n\tstack.data[stack.top++] = e;\n\treturn true;\n&#125;\n// 出栈\nbool Pop(SqStack&amp; stack, int&amp; e) &#123;\n\tif (stack.top == 0) &#123;\n\t\treturn false;\n\t&#125;\n\te = stack.data[stack.top-1];\n\tstack.top--;\n\treturn true;\n&#125;\n// 获取栈顶\nbool GetTop(SqStack&amp; stack, int&amp; e) &#123;\n\tif (stack.top == 0) &#123;\n\t\treturn false;\n\t&#125;\n\te = stack.data[stack.top - 1];\n\treturn true;\n&#125;\n// 遍历\nvoid PrintStack(SqStack&amp; stack) &#123;\n\tfor (int i = 0; i &lt; stack.top; i++) &#123;\n\t\tprintf(\"%d\\t\", stack.data[i]);\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n栈的应用括号匹配// 括号匹配\nint MatchKuohao(SqStack&amp; L, const char* s, int len) &#123;\n\tchar c = 0;\n//\tprintf(\"%d\\n\",len);\n\tfor (int i = 0; i &lt; len; i++) &#123;\n\t\tc = s[i];\n\t\t// 1.判断是否为左括号 是就入栈\n\t\tif (c == '(' || c == '&#123;' || c == '[') &#123;\n\t\t\tPush(L, c);\n\t\t&#125;\n\t\telse &#123;\n\t\t\t// 2.是右括号，取出栈顶括号与之匹配\n\t\t\tif (StackEmpty(L)) &#123; // 不存在左括号与之匹配，代表失败\n\t\t\t\treturn 1;\n\t\t\t&#125;\n\t\t\tPop(L, c);\n\t\t\t// 判断是否匹配\n\t\t\tif (s[i] == ')' &amp;&amp; c != '('||s[i] == '&#125;' &amp;&amp; c != '&#123;'||s[i] == ']' &amp;&amp; c != '[') &#123;\n\t\t\t\treturn 2;\n\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t// 3.在判断栈是否有左括号未匹配的\n\tif (!StackEmpty(L)) &#123;\n\t\treturn 3;\n\t&#125;\n\treturn 0;\n&#125;\nint main()\n&#123;\n\tSqStack L;\n\t// 括号匹配开始\n\tconst char* s = \"(&#123;()&#125;)\";\n\tint b = MatchKuohao(L, s, strlen(s));\n\tprintf(\"%s\", s);\n\tif (b == 0) &#123;\n\t\tprintf(\"括号匹配成功\\n\");\n\t&#125;\n\telse if (b == 1) &#123;\n\t\tprintf(\"括号匹配失败, 右括号多了\\n\");\n\t&#125;\n\telse if (b == 2) &#123;\n\t\tprintf(\"括号匹配失败，左右括号不匹配\\n\");\n\t&#125;\n\telse if (b == 3) &#123;\n\t\tprintf(\"括号匹配失败， 左括号多了\\n\");\n\t&#125;\n\treturn 0;\n&#125;\n\n中缀转后缀及计算#include &lt;string.h&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\nusing namespace std;\n\n&#x2F;&#x2F; 对比运算符(当c1 &gt;&#x3D; c2 返回1， 当 c1 &lt; c2 返回-1 ）\nint CompareCal(char c1, char c2) &#123;&#x2F;&#x2F; c1，c2 是运算符，假定只有+-*&#x2F;\n\tswitch (c1) &#123;\n\tcase &#39;+&#39;:case &#39;-&#39;:\n\t\tif (c2 &#x3D;&#x3D; &#39;*&#39; || c2 &#x3D;&#x3D; &#39;&#x2F;&#39;)&#x2F;&#x2F; “+ -”小于“* &#x2F;”\n\t\t\treturn -1;\n\t&#125;\n\treturn 1;&#x2F;&#x2F; 默认大于\n&#125;\nint Cal(int val1, char op, int val2) &#123;\n\tswitch (op) &#123;\n\tcase &#39;+&#39;:\n\t\treturn val1 + val2;\n\tcase &#39;-&#39;:\n\t\treturn val1 - val2;\n\tcase &#39;*&#39;:\n\t\treturn val1 * val2;\n\tcase &#39;&#x2F;&#39;:\n\t\treturn val1 &#x2F; val2;\n\t&#125;\n\treturn 0;\n&#125;\n&#x2F;&#x2F; 1.中缀转后缀表达式生成算法\nstring GenerateHou(stack&lt;char&gt;&amp; opstack, string&amp; s) &#123;\n\n\t&#x2F;&#x2F;存储后缀表达式\n\tstring hous;\n\t&#x2F;&#x2F;分别储存当前字符串的字符 、 运算符栈中的字符\n\tchar curc,zhanc;\n\n\tfor(int i&#x3D;0;i&lt;s.length();i++)&#123;\n\t\tcurc&#x3D;s[i];\n\n\t\t&#x2F;&#x2F;1.遇到操作数，直接将它输出\n\t\tif(isdigit(curc))&#123;\n\t\t\thous&#x3D;hous+curc;\n\t\t&#125;\n\t\t&#x2F;&#x2F;2.遇到（，直接push\n\t\telse if(curc&#x3D;&#x3D;&#39;(&#39;)&#123;\n\t\t\topstack.push(curc);\n\t\t&#125;\n\t\t&#x2F;&#x2F;遇到），栈元素弹出并输出，知道遇到左括号（左括号只弹出，不输出）\n\t\telse if(curc&#x3D;&#x3D;&#39;)&#39;)&#123;\n\t\t\tzhanc&#x3D;opstack.top();\n\t\t\topstack.pop();\n\t\t\twhile(zhanc!&#x3D;&#39;(&#39;)&#123;\n\t\t\t\thous&#x3D;hous+zhanc;\n\t\t\t\tzhanc&#x3D;opstack.top();\n\t\t\t\topstack.pop();\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F;其他运算符的情况\n\t\t&#x2F;&#x2F;如果栈为空，直接Push\n\t\t&#x2F;&#x2F;如果栈顶是(，直接push\n\t\t&#x2F;&#x2F;如果栈顶是运算符，判断优先级，优先级高或相同的pop并输出，直到遇到优先级低的，将curc入栈\n\t\telse&#123;\n\t\t\twhile(!opstack.empty())&#123;\n\t\t\t\tzhanc&#x3D;opstack.top();\n\t\t\t\tif(zhanc&#x3D;&#x3D;&#39;(&#39;)&#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\tif(CompareCal(zhanc,curc)&#x3D;&#x3D;1)&#123;\n\t\t\t\t\thous&#x3D;hous+zhanc;\n\t\t\t\t\topstack.pop();\n\t\t\t\t&#125;\n\t\t\t\telse&#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\topstack.push(curc);\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 把栈中剩下的放入后缀表达式中\n\twhile (!opstack.empty()) &#123;\n\t\tzhanc &#x3D; opstack.top();\n\t\topstack.pop();\n\t\thous &#x3D; hous + zhanc;\n\t&#125;\n\treturn hous;\n\n&#125;\n&#x2F;&#x2F; 2.后缀表达式计算\nint CalHou(stack&lt;int&gt;&amp; distack, string&amp; s) &#123;\n\tint left,right;\n\tint sum;\n\tchar curc;\n\tfor(int i&#x3D;0;i&lt;s.length();i++)&#123;\n\t\tcurc&#x3D;s[i];\n\t\tif(isdigit(curc))&#123;\n\t\t\tdistack.push(curc-&#39;0&#39;);&#x2F;&#x2F;转换成数字\n\t\t&#125;else&#123;\n\t\t\tleft&#x3D;distack.top();\n\t\t\tdistack.pop();\n\t\t\tright&#x3D;distack.top();\n\t\t\tdistack.pop();\n\t\t\tsum&#x3D;Cal(left,curc,right);\n\t\t\tdistack.push(sum);\n\t\t&#125;\n\t&#125;\n\treturn sum;\n&#125;\n\n队列数组实现#include &lt;stdio.h>\n#include &lt;stdlib.h>\n#define MaxSize 5\ntypedef struct &#123;\n\tint data[MaxSize];\n\tint front, rear;  //rear指向下一个要插入数据的位置\n&#125;SqQueue;\n// 初始化\nvoid InitQueue(SqQueue&amp; Q) &#123;\n\tQ.front= Q.rear=0;\n&#125;\n// 判断为空\nbool QueueEmpty(SqQueue&amp; Q) &#123;\n\treturn Q.rear=Q.front;\n&#125;\n// 入队 - 只能在队尾插入\nbool EnQueue(SqQueue&amp; Q, int e) &#123;\n\tif((Q.rear+1)%MaxSize==Q.front)&#123;  //判断是否为满，实际上浪费了一个存储空间\n\t\treturn false;\n\t&#125;\n\tQ.data[Q.rear]=e;\n\tQ.rear=(Q.rear+1)%MaxSize;\n\treturn true;\n&#125;\n// 出队 - 只能在队头出\nbool DeQueue(SqQueue&amp; Q, int&amp; e) &#123;\n\tif(Q.rear==Q.front)&#123;\n\t\treturn false;\n\t&#125;\n\te=Q.data[Q.front];\n\tQ.front=(Q.front+1)%MaxSize;\n\treturn true;\n&#125;\n// 读队头元素\nbool GetHead(SqQueue&amp; Q, int&amp; e) &#123;\n\tif(Q.rear==Q.front)&#123;\n\t\treturn false;\n\t&#125;\n\te=Q.data[Q.front];\n\treturn true;\n&#125;\nint GetSize(SqQueue&amp; Q) &#123;\n\treturn (Q.rear+MaxSize-Q.front)%MaxSize;\n&#125;\n// 打印\nvoid PrintSqQueue(SqQueue&amp; Q) &#123;\n\tif(Q.rear==Q.front)&#123;\n\t\treturn;\n\t&#125;\n\tfor(int i=Q.front;i!=Q.rear;)&#123;\n\t\tprintf(\"%d\\t\",Q.data[i]);\n\t\ti=(i+1)%MaxSize;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n链表实现#include &lt;stdio.h>\n#include &lt;stdlib.h>\n// 带头结点\ntypedef struct LinkNode &#123;\n\tint data;\n\tstruct LinkNode* next;\n&#125;LinkNode;\n\ntypedef struct &#123;\n\tLinkNode* front, * rear;\n&#125;LinkQueue;\n// 初始化\nvoid InitQueue(LinkQueue&amp; Q) &#123;\n\tLinkNode* s=(LinkNode*)malloc(sizeof(LinkNode));\n\tQ.front=Q.rear=s;\n\tQ.front->next=NULL;\n&#125;\n// 判断为空\nbool QueueEmpty(LinkQueue&amp; Q) &#123;\n\treturn Q.front->next==NULL;\n&#125;\n// 入队 - 只能在队尾插入\nbool EnQueue(LinkQueue&amp; Q, int e) &#123;\n\tLinkNode* s=(LinkNode*)malloc(sizeof(LinkNode));\n\ts->data=e;\n\tQ.rear->next=s;\n\ts->next=NULL;\n\tQ.rear=s;\n\treturn true;\n&#125;\n// 出队 - 只能在队头出\nbool DeQueue(LinkQueue&amp; Q, int&amp; e) &#123;\n\tif(QueueEmpty(Q)) return false;\n\tLinkNode* s=Q.front->next;\n\te=s->data;\n\tQ.front->next=s->next;\n\tif(s==Q.rear)&#123;\n\t\tQ.rear=Q.front;\n\t&#125;\n\tfree(s);\n\treturn true;\n&#125;\n// 读队头元素\nbool GetHead(LinkQueue&amp; Q, int&amp; e) &#123;\n\tif(QueueEmpty(Q)) return false;\n\tLinkNode* s=Q.front->next;\n\te=s->data;\n\treturn true;\n&#125;\nint GetSize(LinkQueue&amp; Q) &#123;\n\tint size=0;\n\tLinkNode* s=Q.front->next;\n\twhile(s!=NULL)&#123;\n\t\tsize++;\n\t\ts=s->next;\n\t&#125;\n\treturn size;\n&#125;\n// 打印\nvoid PrintLiStack(LinkQueue&amp; Q) &#123;\n\tLinkNode* s=Q.front->next;\n\twhile(s!=NULL)&#123;\n\t\tprintf(\"%d\\t\",s->data);\n\t\ts=s->next;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n串#include &lt;stdio.h>\n#include &lt;string.h>\n#define MAXLEN 255\nusing namespace std;\n\n//位序从0开始\ntypedef struct&#123;\n\tchar ch[MAXLEN];\n\tint length;\n&#125;SString;\n\n//将chars赋值给串\nbool StrAssign(SString&amp; T,char *chars)\n&#123;\n\tif(strlen(chars)>MAXLEN)\n\t\treturn false;\n\telse\n\t&#123;\n\t\tT.length=strlen(chars);\n\t\tfor(int i=0;i&lt;T.length;i++)&#123;\n\t\t\tT.ch[i]=*(chars+i);\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n&#125;\n\n//打印\nvoid print(SString T)&#123;\n\tfor(int i=0;i&lt;T.length;i++)&#123;\n\t\tprintf(\"%c\\t\",T.ch[i]);\n\t&#125;\n\tprintf(\"长度：%d\\n\",T.length);\n&#125;\n\n//将串s复制到串t\nbool StrCopy(SString&amp; T,SString S)\n&#123;\n\tint i;\n\tfor(i=0;i&lt;S.length;i++)\n\t\tT.ch[i]=S.ch[i];\n\treturn true;\n&#125;\n\n//判断是否为空\nbool StrEmpty(SString T)&#123;\n\treturn T.length>0?0:1;\n&#125;\n\n//清空\nbool ClearString(SString&amp; T)&#123;\n\tT.length=0;\n\treturn true;\n&#125;\n\n//串T由两个串连接起来\nbool Concat(SString&amp; T,char* s1,char*s2)&#123;\n\tif(strlen(s1)+strlen(s2)>MAXLEN)&#123;\n\t\treturn false;\n\t&#125;else&#123;\n\t\tT.length=strlen(s1)+strlen(s2);\n\t\tint i;\n\t\tfor(i=0;i&lt;strlen(s1);i++)&#123;\n\t\t\tT.ch[i]=*(s1+i);\n\t\t&#125;\n\t\tfor(int j=0;i&lt;T.length;i++)&#123;\n\t\t\tT.ch[i]=*(s2+j);\n\t\t\tj++;\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n\n&#125;\n\n//取子串\nbool SubString(SString &amp;Sub,SString S,int pos,int len)\n&#123;\n\tif(pos+len-1>S.length)&#123;\n\t\treturn false;\n\t&#125;else&#123;\n\t\tfor(int i=pos;i&lt;pos+len;i++)&#123;\n\t\t\tSub.ch[i-pos]=S.ch[i];\n\t\t&#125;\n\t\tSub.length=len;\n\t\treturn true;\n\t&#125;\n&#125;\n\n//比较操作\nint StrCompare(SString s,SString t)&#123;\n\tfor(int i=0;i&lt;s.length&amp;&amp;i&lt;t.length;i++)&#123;\n\t\tif(s.ch[i]!=t.ch[i])&#123;\n\t\t\treturn s.ch[i]-t.ch[i];\n\t\t&#125;\n\t&#125;\n\treturn s.length-t.length;\n&#125;\n\n//找到子串的位置\nint Index(SString s,SString t)&#123;\n\tint i=0;\n\tSString sub;\n\twhile(i&lt;=s.length-t.length)&#123;\n\t\tSubString(sub,s,i,t.length);\n\t\tif(StrCompare(sub,t)!=0)&#123;\n\t\t\ti++;\n\t\t&#125;else&#123;\n\t\t\treturn i;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\n\n//朴素匹配\nint PsIndex(SString t,SString s)&#123;\n\tint k=0;\n\tint i=0,j=0;\n\twhile(i&lt;t.length&amp;&amp;j&lt;s.length)&#123;\n\t\tif(t.ch[i]==s.ch[j])&#123;\n\t\t\ti++;\n\t\t\tj++;\n\t\t&#125;else&#123;\n\t\t\tk++;\n\t\t\ti=k;\n\t\t\tj=0;\n\t\t&#125;\n\t&#125;\n\tif(j=s.length)&#123;\n\t\treturn k;\n\t&#125;\n\telse&#123;\n\t\treturn -1;\n\t&#125;\n&#125;\n\nkmp 算法略。\n树二叉树基本操作数组实现#include &lt;stdio.h>\n#include &lt;cmath>\n\n#define TreeSize 99\n#define MaxSize 100\n/*\n以完全二叉树形式存储结点\ni的左孩子：2i\ni的右孩子：2i+1\ni的父节点：i/2 向下取整\ni所在的层次（深度）：log2 (n) + 1\n*/\nstruct TreeNode &#123;\n\tint value; \t\t// 节点中的数据元素\n\tbool isEmpty; \t// 结点是否为空\n&#125;;\n// 初始化\nvoid InitTreeNode(TreeNode(&amp;t)[MaxSize]) &#123;\n\tfor(int i=0;i&lt;=MaxSize;i++)&#123;\n\t\tt[i].isEmpty=true;\n\t&#125;\n&#125;\n// 位序i结点的左孩子\nTreeNode GetLeftC(TreeNode(&amp;t)[MaxSize], int i) &#123;\n\tint j=2*i;\n\tif(j&lt;1||j>MaxSize||t[j].isEmpty) return t[0];\n\treturn t[j];\n&#125;\n// 位序i结点的右孩子\nTreeNode GetRightC(TreeNode(&amp;t)[MaxSize], int i) &#123;\n\tint j=2*i+1;\n\tif(j&lt;1||j>MaxSize||t[j].isEmpty) return t[0];\n\treturn t[j];\n&#125;\n// 位序i结点的父结点\nTreeNode GetParentC(TreeNode(&amp;t)[MaxSize], int i) &#123;\n\tint j=i/2;\n\tif(j&lt;1||j>MaxSize||t[j].isEmpty) return t[0];\n\treturn t[j];\n&#125;\n// 位序i结点层次（深度）\nint GetDepth(TreeNode(&amp;t)[MaxSize], int i) &#123;\n\tif(i&lt;1||i>MaxSize) return 0;\n\tint j=log(i)/log(2)+1;\n\treturn j;\n&#125;\n// 在位序i的位置插入一个结点\nbool InsertTreeNode(TreeNode(&amp;t)[MaxSize], int i, int e) &#123;\n\tif(i&lt;1||i>MaxSize)&#123;\n\t\treturn false;\n\t&#125;\n\tTreeNode s;\n\ts.isEmpty=false;\n\ts.value=e;\n\tt[i]=s;\n\treturn true;\n&#125;\n// 删除在位序i的位置上的结点 - 要注意把他的左右孩子也删除\nbool DeleteTreeNode(TreeNode(&amp;t)[MaxSize], int i, int&amp; e) &#123;\n\tif(i&lt;1||i>MaxSize) return false;\n\n\tDeleteTreeNode(t,2*i,e);\n\tDeleteTreeNode(t,2*i+1,e);\n\n\te=t[i].value;\n\tt[i].isEmpty=true;\n\treturn true;\n&#125;\n// 顺序遍历\nvoid PrintTreeNodeOrder(TreeNode(&amp;t)[MaxSize]) &#123;\n\tfor(int i=1;i&lt;MaxSize;i++)&#123;\n\t\tif(!t[i].isEmpty)&#123;\n\t\t\tprintf(\"%d\\t\",t[i].value);\n\t\t&#125;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n// 遍历各个结点详细信息\nvoid PrintTreeNodeAll(TreeNode(&amp;t)[MaxSize], int maxn) &#123;\n\tTreeNode tn1, tn2, tn3;\n\tint depth;\n\tfor (int i = 1; i &lt; maxn; i++) &#123;\n\t\tif (t[i].isEmpty) &#123;\n\t\t\tprintf(\"%d结点为空\\n\", i);\n\t\t\tcontinue;\n\t\t&#125;\n\t\ttn1 = GetLeftC(t, i);\t// 左结点\n\t\ttn2 = GetRightC(t, i);  // 有结点\n\t\ttn3 = GetParentC(t, i); // 父亲结点\n\t\tif (!tn3.isEmpty) &#123;\n\t\t\tprintf(\"%d结点的父结点是：%d\\t\", i, tn3.value);\n\t\t&#125;\n\t\telse &#123;\n\t\t\tprintf(\"%d结点没有父结点 \\t\", i);\n\t\t&#125;\n\t\tif (!tn1.isEmpty) &#123;\n\t\t\tprintf(\"%d结点的左结点是：%d\\t\", i, tn1.value);\n\t\t&#125;\n\t\telse &#123;\n\t\t\tprintf(\"%d结点没有左结点 \\t\", i);\n\t\t&#125;\n\t\tif (!tn2.isEmpty) &#123;\n\t\t\tprintf(\"%d结点的右结点是：%d\\t\", i, tn2.value);\n\t\t&#125;\n\t\telse &#123;\n\t\t\tprintf(\"%d结点没有右结点 \\t\", i);\n\t\t&#125;\n\t\tdepth = GetDepth(t, i);\n\t\tprintf(\"%d结点的深度是%d\\n\", i, depth);\n\t&#125;\n&#125;\n\n链表实现#include &lt;stdio.h>\n#include &lt;stdlib.h>\n#include &lt;cmath>\n//三叉链表\ntypedef struct BiTNode &#123;\n\tint data; \t\t// 数据域\n\tstruct BiTNode* lchild, * rchild;// 左右孩子指针\n\tstruct BiTNode* parent;// 父亲结点\n&#125;BiTNode, * BiTree;\n// 插入根结点\nbool InsertRootNode(BiTree&amp; btree, int e) &#123;\n\tbtree=(BiTNode*)malloc(sizeof(BiTNode));\n\tbtree->data=e;\n\tbtree->lchild=NULL;\n\tbtree->rchild=NULL;\n\tbtree->parent=NULL;\n\treturn true;\n&#125;\n// 1.当前p结点的左孩子\nBiTNode* GetLeftC(BiTNode* p) &#123;\n\tif(p==NULL) return NULL;\n\treturn p->lchild;\n&#125;\n// 2.当前p结点的右孩子\nBiTNode* GetRightC(BiTNode* p) &#123;\n\tif(p==NULL) return NULL;\n\treturn p->rchild;\n&#125;\n// 3.当前p结点的父亲\nBiTNode* GetParent(BiTNode* p) &#123;\n\tif(p==NULL) return NULL;\n\treturn p->parent;\n&#125;\n// 当前结点c插入一个左结点\nbool InsertTreeLeftNode(BiTree&amp; c, int e) &#123;\n\tif(c==NULL) return false;\n\tBiTNode* s=(BiTree)malloc(sizeof(BiTree));\n\ts->data=e;\n\ts->parent=c;\n\ts->lchild=NULL;\n\ts->rchild=NULL;\n\tc->lchild=s;\n\treturn true;\n&#125;\n// 当前c结点插入一个右结点\nbool InsertTreeRightNode(BiTree&amp; c, int e) &#123;\n\tif(c==NULL) return false;\n\tBiTNode* s=(BiTree)malloc(sizeof(BiTree));\n\ts->data=e;\n\ts->parent=c;\n\ts->lchild=NULL;\n\ts->rchild=NULL;\n\tc->rchild=s;\n\treturn true;\n&#125;\n// 删除c节点 : 要删除c结点的左右结点，并且释放空间\nbool DeleteTreeNode(BiTree&amp; c) &#123;\n\tif(c==NULL) return false;\n\n\tif(c->lchild!=NULL)&#123;\n\t\tDeleteTreeNode(c->lchild);\n\t&#125;\n\tif(c->rchild!=NULL)&#123;\n\t\tDeleteTreeNode(c->rchild);\n\t&#125;\n\n\tif(c->parent!=NULL)&#123;\n\t\tBiTNode* s=c->parent;\n\t\tif(c==s->lchild)&#123;\n\t\t\ts->lchild=NULL;\n\t\t&#125;else&#123;\n\t\t\ts->rchild=NULL;\n\t\t&#125;\n\t&#125;\n\n\tfree(c);\n\treturn true;\n&#125;\n// 判断二叉树是否为空\nbool Empty(BiTree&amp; root) &#123;\n\treturn root==NULL?true:false;\n&#125;\n// 辅助方法：中序遍历\nvoid InOrder(BiTree p) &#123;// 不能引用类型\n\tif (p != NULL) &#123;\n\t\tInOrder(p->lchild);\n\t\tprintf(\"%d  \", p->data);\n\t\tInOrder(p->rchild);\n\t&#125;\n&#125;\n\n遍历// 本小节重点------------------------------------------------\n// 前序遍历\nvoid PreOrder(BiTree p) &#123;// 不能引用类型\n\tif (p != NULL) &#123;\n\t\tprintf(\"%d  \", p->data);\n\t\tPreOrder(p->lchild);\n\t\tPreOrder(p->rchild);\n\t&#125;\n&#125;\n// 中序遍历\nvoid InOrder(BiTree p) &#123;// 不能引用类型\n\tif (p != NULL) &#123;\n\t\tInOrder(p->lchild);\n\t\tprintf(\"%d  \", p->data);\n\t\tInOrder(p->rchild);\n\t&#125;\n&#125;\n// 后序遍历\nvoid PostOrder(BiTree p) &#123;// 不能引用类型\n\tif (p != NULL) &#123;\n\t\tPostOrder(p->lchild);\n\t\tPostOrder(p->rchild);\n\t\tprintf(\"%d  \", p->data);\n\t&#125;\n&#125;\n// 层次遍历\nvoid CenCi(BiTree&amp; root) &#123;\n\tqueue&lt;BiTNode*> que;\n\tque.push(root);\n\tBiTNode* p;\n\twhile(!que.empty())&#123;\n\t\tp=que.front();\n\t\tque.pop();\n\t\tprintf(\"%d \",p->data);\n\t\tif(p->lchild!=NULL)&#123;\n\t\t\tque.push(p->lchild);\n\t\t&#125;\n\t\tif(p->rchild!=NULL)&#123;\n\t\t\tque.push(p->rchild);\n\t\t&#125;\n\t&#125;\n&#125;\n// 难点------------------------------------------------\n// 非递归遍历\nvoid PreOrderDiTui(BiTree&amp; root) &#123;// 前序\n\tstack&lt;BiTNode*> bistack;\n\tBiTNode* p=root;\n\twhile(p!=NULL||!bistack.empty())&#123;\n\t\tif(p!=NULL)&#123;\n\t\t\tbistack.push(p);\n\t\t\tprintf(\"%d \",p->data);\n\t\t\tp=p->lchild;\n\t\t&#125;else&#123;\n\t\t\tp=bistack.top();\n\t\t\tbistack.pop();\n\t\t\tp=p->rchild;\n\t\t&#125;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\nvoid InOrderDiTui(BiTree&amp; root) &#123;// 中序\n\tstack&lt;BiTNode*> bistack;\n\tBiTNode* p = root;\n\twhile (p != NULL || !bistack.empty()) &#123;\n\t\tif (p != NULL) &#123;\n\t\t\tbistack.push(p);\n\t\t\tp = p->lchild;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tp = bistack.top();\n\t\t\tbistack.pop();\n\t\t\tprintf(\"%d  \", p->data);\n\t\t\tp = p->rchild;\n\t\t&#125;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\nvoid PostOrderDiTui(BiTree&amp; root) &#123;// 后序\n\tstack&lt;BiTNode*> bistack;\n\tBiTNode* p = root;\n\tBiTNode* lastp = NULL;// 上一个访问的结点 ,关键点！，用来判断是否右子树返回\n\twhile(p!=NULL||!bistack.empty())&#123;\n\t\tif(p!=NULL)&#123;\n\t\t\tbistack.push(p);\n\t\t\tp=p->lchild;\n\t\t&#125;else&#123;\n\n\t\t\tp=bistack.top();\n\n\t\t\t//此时有两种可能\n\t\t\t//1.访问完左子树再次回到父节点(需继续访问右子树，如果右子树为空就不访问了)\n\t\t\t//2.访问完右子树或右子树为空（直接pop并访问）\n\t\t\tif(p->rchild==NULL||lastp==p->rchild)&#123;\n\t\t\t\tbistack.pop();\n\t\t\t\tprintf(\"%d \",p->data);\n\t\t\t\tlastp=p;\n\t\t\t\tp=NULL;\n\t\t\t&#125;else&#123;\n\t\t\t\tp=p->rchild;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n由遍历序列构建二叉树必须要有中序遍历序列才可以。\n线索二叉树\n（错误：rtag&#x3D;1）\n\n\n\n\n\n树的存储结构双亲表示法\n孩子表示法\n孩子兄弟表示法\n\n\n二叉排序树（BTS）\n#include &lt;stdio.h>\n#include &lt;stdlib.h>\n//二叉排序树\n\ntypedef struct BSTNode\n&#123;\n\tint data;\n\tBSTNode *lchild;  //左孩子\n\tBSTNode *rchild;  //右孩子\n&#125;BSTNode, *BSTree;\n\nBSTNode* Search(BSTree t, int key)&#123;\n\twhile(t!=NULL&amp;&amp;key!=t->data)&#123; //如果查找到空，或查找到对应值，退出循环\n\t\tif(key&lt;t->data)&#123;\n\t\t\tt=t->lchild;\n\t\t&#125;else&#123;\n\t\t\tt=t->rchild;\n\t\t&#125;\n\t&#125;\n\treturn t;\n&#125;\n\nvoid InOderTraverse(BSTree bst)   //中序递归遍历二叉树\n&#123;\n\tif (NULL != bst)\n\t&#123;\n\t\tInOderTraverse(bst->lchild);\n\t\tprintf(\"%d \", bst->data);\n\t\tInOderTraverse(bst->rchild);\n\t&#125;\n&#125;\n\n//插入节点\nbool Insert(BSTree &amp;t, int key)\n&#123;\n\tif (NULL == t)  //空树\n\t&#123;\n\t\tt=(BSTree)malloc(sizeof(BSTNode));\n\t\tt->data=key;\n\t\tt->lchild=NULL;\n\t\tt->rchild=NULL;\n\t\treturn true;\n\t&#125;else if(t->data==key) &#123;  //已经存在，插入失败\n\t\tprintf(\"\\nThe node(%d) already exists.\\n\", key);\n\t\treturn false;\n\t&#125;else if(t->data&lt;key)&#123;\n\t\treturn Insert(t->rchild,key);\n\t&#125;else&#123;\n\t\treturn Insert(t->lchild,key);\n\t&#125;\n&#125;\n\n//创建二叉排序树\nvoid create(BSTree &amp;t,int str[],int length)&#123;\n\tfor(int i=0;i&lt;length;i++)&#123;\n\t\tInsert(t,str[i]);\n\t&#125;\n&#125;\n\n/*\n删除分三种情况：\n(1)被删除的节点无孩子，说明该节点是叶子节点，直接删\n(2)被删除的节点只有左孩子或者右孩子，直接删，并将其左孩子或者右孩子放在被删节点的位置\n(3)被删除的节点既有右孩子又有右孩子\n1.找到左子树的最右节点（没有右孩子），来替代删除节点，再由节点的左孩子替代它 ----此处用这种方法\n2.找到右子树的最左节点（没有左孩子），来替代删除节点，再由节点的右孩子替代它\n*/\nbool Delete(BSTree&amp; T, int key)\n&#123;\n\tif (NULL == T||Search(T,key)==NULL)\n\t&#123;\n\t\treturn false;  //空树或者差找不到直接报错\n\t&#125;\n\n\tBSTNode* p=Search(T,key);\n\tBSTNode* q;\n\tBSTNode* s;\n\n\tif ( p->lchild==NULL &amp;&amp;  p->rchild !=NULL)  //无左孩子,有右孩子\n\t&#123;\n\t\tq = p->rchild;\n\t\tp->data = q->data;\n\t\tp->rchild = q->rchild;\n\t\tp->lchild = q->lchild;\n\t\tfree(q);\n\t&#125;\n\telse if (NULL == p->rchild &amp;&amp; NULL != p->lchild)  //无右孩子,有左孩子\n\t&#123;\n\t\tq = p->lchild;\n\t\tp->data = q->data;\n\t\tp->rchild = q->rchild;\n\t\tp->lchild = q->lchild;\n\t\tfree(q);\n\t&#125;\n\telse if (NULL != p->rchild &amp;&amp; NULL != p->lchild) //既有左孩子，又有右孩子\n\t&#123;\n\t\tq = p;\n\t\ts = p->lchild;   //找左孩子的最右孩子--s\n\t\t\twhile (s->rchild)\n\t\t\t&#123;\n\t\t\t\tq = s;    //q存储s的父节点\n\t\t\t\ts = s->rchild;\n\t\t\t&#125;\n\t\t\tp->data = s->data;\n\n\t\t\tif (q != p)\n\t\t\t&#123;\n\t\t\t\tq->rchild = s->lchild;//用s的左孩子替代s\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tq->lchild = s->lchild; //如果p的左孩子没有右孩子，也就是说p的左孩子就是左子树的最右结点\n\t\t\t&#125;\n\t\t\tfree(s);\n\t\t&#125;\n\t\telse  //叶子结点\n\t\t&#123;\n\t\t\tfree(p);\n\t\t&#125;\n\t\treturn true;\n&#125;\n\n平衡二叉树（AVL）\n二叉排序树的平均查找长度（ASL）：\n\n最好情况：O（log2n）——平衡二叉树\n最坏：O（n）\n\n\nLL\n\n\nRR 同理，左旋\n\nLR 先左旋后右旋\n\n\nRL 先右旋后左旋\n\n\n哈夫曼树（最优树）路径长度：路径上经过的边个数\n树的带权路径长度（WPL）：树中所有叶子结点的带权路径长度之和\nWPL 最小的树就是哈夫曼树\n\n\n并查集（Disjoint Set）用森林中的不同树表示互不相关的集合。\n查：查询某个节点所在树的根节点\n并：将两个树合并，也就是将两个集合合并为一个集合 时间复杂度 O（1）\n并查集更适合用双亲表示法实现：合并时改变 parent 数据即可\n初始化：将所有 s[]设为-1\n\n注：Find 操作中，树的高度会影响时间复杂度\n怎么尽可能减小树的高度呢？\n\n经过优化，Find 的时间复杂度最差 O（log2n）\n终极优化：\n\n\n","slug":"数据结构1","date":"2023-03-12T16:00:00.000Z","categories_index":"","tags_index":"基础知识","author_index":"Serena"},{"id":"46426c79fe8370cebf57bb63c792f570","title":"hello","content":"欢迎来到我的个人博客这是一个使用 Hexo Aurora 建立的静态博客文档：https://aurora.tridiamond.tech/zh/guide/范例：\n\nhttps://abyssaler.github.io/\nhttps://blog.yimoorua.top/\n\nMarkdown 语法：https://markdown.com.cn/basic-syntax/\n评论留言功能敬请期待","slug":"hello","date":"2023-02-22T16:00:00.000Z","categories_index":"","tags_index":"介绍","author_index":"Serena"},{"id":"293c17b4d2a4292133cc4d1ffd7f8725","title":"计算机网络","content":"计算机网络最近复习计网，看的是1.6 计算机网络体系结构（2）—分层的必要性_哔哩哔哩_bilibili，讲的很好。\n参考教材是王道的，这里记录了一些补充知识点。\n体系结构网络分层的必要性：\n数据链路层\n\n\n网络层\n\n\n运输层\n\n\n应用层\n\n\n\n\n\n时延问题\n数据链路层检错-循环冗余 CRC\n\n可靠传输的实现机制停止-等待协议 SW\n回退 N\n选择重传 SR\nPPP 协议\n怎么实现透明传输\n\n\n\n\n工作状态\n\n\n\nMAC 地址 IP 地址和 ARP 协议\n集线器和交换机\n\nvlanvlan 可以隔离广播域\n\n网络层虚电路和数据报\nIPV4 地址的三个阶段分类编址-&gt;划分子网-&gt;无分类编址\n\n\n运输层端口号\n超时重传时间的计算\n","slug":"计算机网络","date":"2023-04-04T16:00:00.000Z","categories_index":"","tags_index":"基础知识","author_index":"Serena"},{"id":"36c6381217e805c389535529f356949e","title":"数据结构（2）","content":"图图的存储方式邻接矩阵法\n\n\n空间复杂度 O(n2)，不适合存储稀疏图，浪费空间\n\n矩阵相乘：A^(2)得到的矩阵代表从顶点 i 到 j 长度为 2 的路径条数\n邻接表法\n十字链表（有向图）\n邻接多重表（无向图）当使用邻接表存储时，一条边会对应两份冗余数据，删除节点时很麻烦\n\n\n\n遍历#include &lt;stdio.h>\n#include &lt;stdlib.h>\n#include &lt;queue> // 借助队列，实现广度优先遍历\nusing namespace std;\n\n//用邻接矩阵存储的无向图\n\n#define MAXVEX  100                      //最大顶点数\n#define INFINITY    65535               //用65535来代表无穷大\n\n\nbool visited[MAXVEX]=&#123;false&#125;;\n\n\ntypedef struct\n&#123;\n    int vexs[MAXVEX];            //顶点表\n    int  arc[MAXVEX][MAXVEX];         //邻接矩阵，可看作边\n    int  numVertexes, numEdges;      //图中当前的顶点数和边数\n&#125;Graph;\n\nint findIndex(Graph g,int i)&#123;\n\t//找到i对应的下标\n\tint index=-1;\n\tfor(int j=0;j&lt;g.numVertexes;j++)&#123;\n\t\tif(g.vexs[j]==i)&#123;\n\t\t\tindex=j;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\tif(index==-1)&#123;\n\t\tprintf(\"图中不存在对应节点\");\n\t&#125;\n\treturn index;\n&#125;\n\nvoid CreateGraph(Graph &amp;G) &#123;\n\t/*初始化图的基本信息*/\n\t//输入图中顶点\n\tprintf(\"请输入图中顶点数量：\");\n\tscanf(\"%d\",&amp;G.numVertexes);\n\tfor(int i=0;i&lt;G.numVertexes;i++)&#123;\n\t\tprintf(\"请输入第%d个顶点:\",i+1);\n\t\tscanf(\"%d\",&amp;G.vexs[i]);\n\t&#125;\n\t//输入图中的边\n\tprintf(\"请输入图中边的数量：\");\n\tscanf(\"%d\",&amp;G.numEdges);\n\t//初始化邻接矩阵\n\tfor(int i=0;i&lt;G.numVertexes;i++)&#123;\n\t\tfor(int j=0;j&lt;G.numVertexes;j++)&#123;\n\t\t\tG.arc[i][j] = 0;  //初始化时顶点间都不存在边\n\t\t&#125;\n\t&#125;\n\t//构造邻接矩阵\n\tfor(int k=0;k&lt;G.numEdges;k++) &#123;\n\t\tint v1,v2;\n\t\tprintf(\"请输入第%d条边（如：AB):\",k+1);\n\t\tscanf(\"%d %d\",&amp;v1,&amp;v2);\n\t\tint i=findIndex(G,v1);\n\t\tint j=findIndex(G,v2);\n\t\tG.arc[i][j] = 1;  //存在边就设置为1\n\t\tG.arc[j][i] = 1;  //由于是无向图所以相反反向也存在边\n\t&#125;\n\tprintf(\"图创建成功！\\n\");\n&#125;\n\n//找到第一个与下标index的点相邻的点 ,-1表示找不到\nint firstNeighbor(Graph g,int index)&#123;\n\tfor(int j=0;j&lt;g.numVertexes;j++)&#123;\n\t\tif(g.arc[index][j]==1)&#123;\n\t\t\treturn j;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\n\n//找到下一个相邻的点\nint nextNeighbor(Graph g,int index,int now)&#123;\n\tfor(int j=now+1;j&lt;g.numVertexes;j++)&#123;\n\t\tif(g.arc[index][j]==1)&#123;\n\t\t\treturn j;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\n\nvoid bfs (Graph g,int i)   //广度优先遍历\n&#123;\n\n\tqueue&lt;int> que;\n\tprintf(\"%d \",g.vexs[i]);\n\tvisited[i]=true;\n\tque.push(i);\n\twhile(!que.empty())&#123;\n\t\tint index=que.front();\n\t\tque.pop();\n\t\tfor(int j=firstNeighbor(g,index);j>=0;j=nextNeighbor(g,index,j))&#123; //访问所有与i相连的节点\n\t\t\tif(!visited[j])&#123;  //只会访问未被访问的节点\n\t\t\t\tprintf(\"%d \",g.vexs[j]);\n\t\t\t\tvisited[j]=true;\n\t\t\t\tque.push(j);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n&#125;\n\nvoid BFSTraverse(Graph g,int i)&#123;\n\tfor(int j=0;j&lt;g.numVertexes;j++)&#123;  //将所有节点标志为未访问\n\t\tvisited[j]=false;\n\t&#125;\n\tint index=findIndex(g,i);\n\tif(index==-1) return;\n\n\tbfs(g,index);//如果直接从0节点开始遍历，可以省去这一行代码\n\n\t//如果是非连通图，则经过bfs还会有子图未访问到，遍历visited找还没有访问的点\n\tfor(int j=0;j&lt;g.numVertexes;j++)&#123;\n\t\tif(!visited[j])&#123;\n\t\t\tbfs(g,j);\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid dfs(Graph g,int i)&#123;\n\tprintf(\"%d \",g.vexs[i]);\n\tvisited[i]=true;\n\tfor(int j=firstNeighbor(g,i);j>=0;j=nextNeighbor(g,i,j))&#123; //访问所有与i相连的节点\n\t\t\tif(!visited[j])&#123;  //只会访问未被访问的节点\n\t\t\t\tdfs(g,j);\n\t\t\t&#125;\n\t\t&#125;\n&#125;\n\nvoid DFSTraverse(Graph g)&#123;\n\tfor(int j=0;j&lt;g.numVertexes;j++)&#123;  //将所有节点标志为未访问\n\t\tvisited[j]=false;\n\t&#125;\n\n\t//如果是非连通图，则经过bfs还会有子图未访问到，遍历visited找还没有访问的点\n\t//从0开始遍历\n\tfor(int j=0;j&lt;g.numVertexes;j++)&#123;\n\t\tif(!visited[j])&#123;\n\t\t\tdfs(g,j);\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n广度优先遍历\n\n空间复杂度：O(v) 调用队列\n\n\n深度优先遍历\n\n空间复杂度：O(v) 递归调用栈\n时间复杂度同上\n最小生成树\nKruskal 算法与并查集结合考虑\n最短路径\n单源\n\nBFS（无权图）\n将 BFS 算法中，visit 的部分进行修改\n引入 d[]表示从源点到此节点的路径长度，path[]表示最短路径是从哪个结点过来的\n\n\nDijkstra（带权图，无权图）\n不适合带有负权值的带权图\n\n\n\n\n各顶点的最短路径——Floyd 算法\n\n\n\n时间复杂度 O(v^3)\nFloyd 可以解决带负权的图，但是无法解决带有负权回路的图\n拓扑排序\n关键路径查找线性存储顺序查找两种优化：\n\n有序，产生查找判定树，降低 ASL 失败\n被查的概率不同，将该率高的放前面，降低 ASL 成功\n\n无论怎么优化，时间复杂度 O(n)\n折半查找while(low&lt;high)&#123;  //这里改成&lt;=的话\n\tmid=(low+high)/2;\n\tif(a[mid]&lt;i)&#123;\n\t\tlow=mid+1;\n\t&#125;else if(a[mid]>i)&#123;\n\t\thigh=mid;  //这里改成mid+1\n\t&#125;else&#123;\n\t\treturn mid;\n\t&#125;\n&#125;\n\n时间复杂度 O(log2n)\n折半查找判定树：右子树结点数-左子树结点数&#x3D;0&#x2F;1（mid 向下取整），就相当于平衡的二叉排序树，树高与完全二叉树相同\n折半查找的速度一定比顺序查找快么？×\n\n一个好用板子\n\n上：得到 3 的最左边值\n下：得到 3 的最右边值\n分块查找\n\n树形二叉排序树见上一篇\n红黑树性质：\n\n左根右：左&lt;跟&lt;右\n根叶黑：根节点，叶节点（空的失败节点）是黑色的\n不红红：两个红色节点不能相连\n黑路同：从任意节点出发，到叶子结点，所经过的黑色节点个数是相同的\n\n插入：\n\nB 树\n\n\n\n插入：向上分裂\n删除：1.直接删 2.兄弟够借 3.兄弟不够借（合并）\nB+树MySQL 的索引使用 B+树：\nB+树的非叶子节点不含有该关键字对应记录的存储地址，可以使一个磁盘块包含更多的关键字，是的 B+树的阶更大，树高更矮，读磁盘次数更少，查找更快。\n\n散列查找（Hash Table）装填因子 α&#x3D;表中记录数&#x2F;散列表长度，数越大代表冲突约容易发生\n常见的散列函数\n除留余数法——H(key)&#x3D;key%p\n散列表表长 m，取一个不大于 m 但最接近或等于 m 的质数p（看情况而定）\n\n直接定址法——H(key)&#x3D;key&#x2F;H(key)&#x3D;a*key+b\n适合关键字的分布基本连续的情况\n\n数字分析法——选取数码分布比较均匀的若干位作为散列地址\n适用于已知的关键字集合，若更换关键字，则需要重新构造新的散列函数\n\n平方取中法——取关键字的平方值的中间几位作为散列函数\n这种方法得到的散列地址与关键字的每位都有关系，得到的散列地址分布比较均匀\n\n\n哈希冲突的解决办法\n链地址法：将所有关键字为同义词的节点链接在同一个单链表中\n\n开放定址法：\n可存放新表项的空闲地址既可以向它的同义词表项开放，又向它的非同义词表项开放。\nH(i)&#x3D;(H(key)+d(i))%m\ni&#x3D;0,1,2…..,k(k&lt;&#x3D;m-1),m 表示散列表表长，d(i)为增量序列；i 可以理解为第 i 次发生冲突\n不能随意删除元素，要进行标记\n\n线性探测法——d(i)&#x3D;0,1,2,3…,m-1\n即发生冲突时，每次往后探测相邻的下一个单元是否为空\n\n平方探测法——d(i)&#x3D;0,1，-1,2^(2),-2^(2)….k^(2),-k^(2)\n散列表长度 m 必须是 4j+3 的素数，才能探测到所有位置\n\n伪随机序列法——d(i)是伪随机序列\n\n\n\n再哈希法（再散列法）：除了原始的散列函数 H(key)之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止\n\n\n排序插入排序//插入排序\nvoid InsertSort(int a[],int size)&#123;\n\n\tif(size==1||a==NULL) return;\n\n\tfor(int i=0;i&lt;size;i++)&#123;\n\t\tfor(int j=i;j>=1&amp;&amp;a[j]&lt;a[j-1];j--)&#123;\n\t\t\tswap(a,j,j-1);\n\t\t&#125;\n\t&#125;\n&#125;\n\n//直接插入排序-王道实现方法\nvoid InsertSort1(int a[],int size)&#123;\n\n\tif(size==1||a==NULL) return;\n\n\tfor(int i=1;i&lt;size;i++)&#123;\n\t\tif(a[i]&lt;a[i-1])&#123;  //当a[i]小于它的前驱，才会向前排序\n\t\t\tint temp=a[i];\n\t\t\tint j;\n\t\t\tfor(j=i-1;j>=0&amp;&amp;temp&lt;a[j];j--)&#123;\n\t\t\t\ta[j+1]=a[j];\n\t\t\t&#125;\n\t\t\ta[j+1]=temp;\n\t\t&#125;\n\t&#125;\n&#125;\n\n//折半插入排序\nvoid InsertSort2(int a[],int size)&#123;\n\tint left,right,mid;\n\tfor(int i=1;i&lt;size;i++)&#123;\n\t\tint temp=a[i];\n\t\tleft=0;\n\t\tright=i-1;\n\t\twhile(left&lt;right)&#123;  //得到小于等于a[i]的最右侧下标，为了保持稳定性\n\t\t\tmid=(left+right+1)/2;  //向上取整\n\t\t\tif(a[mid]&lt;=temp)&#123;\n\t\t\t\tleft=mid;\n\t\t\t&#125; else&#123;\n\t\t\t\tright=mid-1;\n\t\t\t&#125;\n\t\t&#125;\n\t\tfor(int j=i;j>right+1;j--)&#123;\n\t\t\ta[j]=a[j-1];\n\t\t&#125;\n\t\ta[right+1]=temp;\n\t&#125;\n&#125;\n\n//希尔插入排序\n//希尔排序不稳定且只能基于顺序表实现\nvoid InsertSort3(int a[],int size)&#123;\n\n\tif(size==1||a==NULL) return;\n\n\tfor(int d=size/2;d>=1;d=d/2)&#123;\n\t\tfor(int i=d;i&lt;size;i++)&#123;\n\t\t\tint temp=a[i];\n\t\t\tint j=i-d;\n\t\t\twhile(j>=0&amp;&amp;a[j]>temp)&#123;\n\t\t\t\ta[j+d]=a[j];\n\t\t\t\tj=j-d;\n\t\t\t&#125;\n\t\t\ta[j+d]=temp;\n\t\t&#125;\n\t&#125;\n&#125;\n\n时间：O(n^2) 空间：O(1)\n虽然折半插入排序减少了比较次数，元素的移动次数不变，时间复杂度不变\n//插入排序——链表实现\nvoid InsertSort(LinkList&amp; l)&#123;\n\tif(Length(l)==0||Length(l)==1) return;\n\tLNode* lastSorted=l->next;\n\tLNode* cur=l->next->next;\n\twhile(cur)&#123;\n\t\tif(cur->data>=lastSorted->data)&#123;    //如果当前的值大于前一个值，则说明已经排好序\n\t\t\tlastSorted=cur;\n\t\t\tcur=cur->next;\n\t\t&#125;else&#123;  //需要重头找到要插入的位置\n\t\t\tLNode* temp=l;\n\t\t\twhile(temp->next->data&lt;=cur->data)&#123;\n\t\t\t\ttemp=temp->next;\n\t\t\t&#125;\n\n\t\t\tLNode* s=cur; //用s存储当前cur\n\t\t\tcur=cur->next;  //cur后移\n\t\t\tlastSorted->next=cur;\n\n\t\t\t//节点s要接在temp后面\n\t\t\ts->next= temp->next;\n\t\t\ttemp->next=s;\n\t\t&#125;\n\t&#125;\n&#125;\n\n交换排序冒泡排序void BubbleSort(int a[],int size)&#123;\n\tfor(int i=0;i&lt;size;i++)&#123;  //一共size趟,每一趟确定一个最小值\n\t\tfor(int j=size-2;j>=i;j--)&#123;\n\t\t\tif(a[j]>a[j+1])&#123;  //相等时不交换，保证算法稳定\n\t\t\t\tswap(a,j,j+1);    //最小的值向上浮\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n空间 O(1) 时间 O(n^2)\n快速排序int partition(int a[],int low,int high)&#123;\n\tint pivot=a[low];\n\twhile(low&lt;high)&#123;\n\t\twhile(low&lt;high&amp;&amp;a[high]>=pivot) high--;\n\t\ta[low]=a[high];\n\t\twhile(low&lt;high&amp;&amp;a[low]&lt;=pivot) low++;\n\t\ta[high]=a[low];\n\t&#125;\n\ta[low]=pivot;\n\treturn low;\n&#125;\n\n//快速排序\nvoid QuickSort(int a[], int low,int high)&#123;\n\tif(low&lt;high)&#123;\n\t\tint pivotpos=partition(a,low,high);\n\t\tQuickSort(a,low,pivotpos-1);\n\t\tQuickSort(a,pivotpos+1,high);\n\t&#125;\n&#125;\n\n快排地时间效率依赖于每次划分是否均匀。有序或逆序时，时间复杂度最差，要递归调用 N 层。\n平均时间 O(nlog2n) 空间 O(log2n)\n选择排序简单选择排序void SelectSort(int a[],int size)&#123;\n\tfor(int i&#x3D;0;i&lt;size-1;i++)&#123;  &#x2F;&#x2F;n-1趟，最后一个位置不需要排序\n\t\tint index&#x3D;i;\n\t\tfor(int j&#x3D;i;j&lt;size;j++)&#123;\n\t\t\tif(a[j]&lt;a[index])&#123;    &#x2F;&#x2F;取每一次循环的最小值\n\t\t\t\tindex&#x3D;j;\n\t\t\t&#125;\n\t\t&#125;\n\t\tswap(a,index,i); &#x2F;&#x2F;将最小值放到最前面\n\t&#125;\n&#125;\n\n不论好坏情况 O(n^2)\n堆排序//调整以K为根的子树\nvoid HeadAdjust(int a[],int k,int size)&#123;\n\tint temp=a[k];\n\tfor(int i=2*k;i&lt;=size;i*=2)&#123;\n\t\tif(i&lt;size&amp;&amp;a[i]&lt;a[i+1]) i++;//找到左右孩子中更大的\n\t\tif(temp>=a[i])&#123; //根节点大于孩子，不需要调整\n\t\t\tbreak;\n\t\t&#125;\n\t\tif(temp&lt;a[i])&#123;  //根节点小于孩子\n\t\t\ta[k]=a[i];\n\t\t\tk=i;   //继续向下比较，将比temp大的孩子上移\n\t\t&#125;\n\t&#125;\n\ta[k]=temp;\n&#125;\n\n//建立大跟堆\nvoid BuildMaxHeap(int a[],int size)&#123;\n\t//从非叶子节点开始调整\n\t//非叶子节点下标&lt;=size/2\n\tfor(int i=size/2;i>0;i--)&#123;\n\t\tHeadAdjust(a,i,size);\n\t&#125;\n&#125;\n\n//堆排序\nvoid HeapSort(int a[],int size)&#123;\n\tBuildMaxHeap(a,size);   //将数组转换为大根堆 建堆时间：O(n)\n\t//每一趟都将根节点和堆的最后一个节点互换\n\tfor(int i=size;i>=1;i--)&#123;\n\t\tswap(a,1,i);\n\t\tHeadAdjust(a,1,i-1);   //每次调整o(h)=o(log2n)\n\t&#125;\n&#125;\n\n\n//堆的插入\nvoid InsertHeap(int a[],int&amp; size,int val)&#123;\n\ta[++size]=val;\n\tint i;\n\tfor(i=size;i/2>=1;i=i/2)&#123;\n\t\tif(val>a[i/2])&#123;\n\t\t\ta[i]=a[i/2];\n\t\t&#125;\n\t&#125;\n\ta[i]=val;\n&#125;\n\n//堆的删除\nvoid DeleteHeap(int a[],int&amp; size,int i)&#123;\n\tswap(a,i,size--);\n\tHeadAdjust(a,i,size);\n&#125;\n\n时间复杂度 O(nlog2n)\n归并排序//b数组复制a数组的内容\nint* b=(int*)malloc((6*sizeof(int)));  //空间复杂度O(N)\n\nvoid Merge(int a[],int low,int mid,int high)&#123;\n\tfor(int i=low;i&lt;=high;i++)&#123;\n\t\tb[i]=a[i];\n\t&#125;\n\tint i=low;//左指针\n\tint j=mid+1; //右指针\n\tint k=low; //指向原数组的指针\n\twhile(i&lt;=mid&amp;&amp;j&lt;=high)&#123;\n\t\tif(b[i]&lt;=b[j])&#123;  //保证稳定性\n\t\t\ta[k++]=b[i++];\n\t\t&#125;else&#123;\n\t\t\ta[k++]=b[j++];\n\t\t&#125;\n\t&#125;\n\twhile(i&lt;=mid) a[k++]=b[i++];\n\twhile(j&lt;=high) a[k++]=b[j++];\n&#125;\n\nvoid MergeSort(int a[],int low,int high)&#123;\n\tif(low&lt;high)&#123;\n\t\tint mid=(low+high)/2;\n\t\tMergeSort(a,low,mid);\n\t\tMergeSort(a,mid+1,high);\n\t\tMerge(a,low,mid,high);\n\t&#125;\n&#125;\n\n时间 O(nlog2n)\n基数排序\n\n外部排序外部排序通常使用归并排序法：\n\n根据内存缓冲区大小，将外存上的文件分为若干长度 l 的子文件，一次读入内存并利用内部排序对他们进行排序，并将排序后得到的有序子文件重新写回外存，称这些有序子文件为归并串或顺串。\n对这些归并串进行逐趟归并，使归并段逐渐有小到大，直至整个文件有序。\n\n外部存储的总时间&#x3D;内部排序所需时间+外存信息读写的时间（占用时间最大）+内存归并所需时间\n怎样减少时间？——减少归并趟数—&gt;多路归并\n\n增加初始归并段的长度，即可以减少初始归并段个数 r\n总记录 n，归并段长度 l，r&#x3D;n&#x2F;l 向上取整\n败者树\n\n使用败者树后，内部归并的次数与 k 无关了。因此，只要内存空间足够大，增大归并路数 k 将有效减少归并树的高度，从而减少 I&#x2F;O 次数，提高外部排序的速度。\n置换-选择排序优化途径——减小 r\n\n最佳归并树使用置换-选择排序建立的初始归并段长度各不相同\n\n对于 K 叉归并，若初始归并段的数量无法构成严格的 K 叉归并树，则需要补充几个长度为 0 的虚段，再进行 k 叉哈夫曼树的构造。\n\n","slug":"数据结构2","date":"2023-03-16T16:00:00.000Z","categories_index":"","tags_index":"基础知识","author_index":"Serena"},{"id":"7a897380fbf2b52c7fdc533d413e1985","title":"MyBatis","content":"MyBatismysql 密码：yang\n\n配置数据库路径加入 mysql 和 mybatis 依赖\n连接池配置\n# DataSourceProperties\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/community?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Hongkong\nspring.datasource.username=root\nspring.datasource.password=yang\nspring.datasource.type=com.zaxxer.hikari.HikariDataSource\nspring.datasource.hikari.maximum-pool-size=15\nspring.datasource.hikari.minimum-idle=5\nspring.datasource.hikari.idle-timeout=30000\n\nmybatis 配置，用 entity 类封装表里的数据\n# MybatisProperties\nmybatis.mapper-locations=classpath:mapper/*.xml\nmybatis.type-aliases-package=com.nowcoder.community.entity\nmybatis.configuration.useGeneratedKeys=true\nmybatis.configuration.mapUnderscoreToCamelCase=true\n\nmapper 使用方法\n实体类：get set 函数\ndao 类：设置 mapper 接口，定义对实体类进行操作的函数注解@Mapperinsert 和 update 返回 int，表示修改行数select 返回 user 实体类\nresources&#x2F;mapper 中：mapper.xml 写函数对应的 sql 操作mybatis 官网查找对应模板id 即对应的函数\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.nowcoder.community.dao.UserMapper\">\n\n    &lt;sql id=\"insertFields\">\n        username, password, salt, email, type, status, activation_code, header_url, create_time\n    &lt;/sql>\n\n    &lt;sql id=\"selectFields\">\n        id, username, password, salt, email, type, status, activation_code, header_url, create_time\n    &lt;/sql>\n\n    &lt;select id=\"selectById\" resultType=\"User\">\n        select &lt;include refid=\"selectFields\">&lt;/include>\n        from user\n        where id = #&#123;id&#125;\n    &lt;/select>\n\n    &lt;insert id=\"insertUser\" parameterType=\"User\" keyProperty=\"id\">\n        insert into user (&lt;include refid=\"insertFields\">&lt;/include>)\n        values(#&#123;username&#125;, #&#123;password&#125;, #&#123;salt&#125;, #&#123;email&#125;, #&#123;type&#125;, #&#123;status&#125;, #&#123;activationCode&#125;, #&#123;headerUrl&#125;, #&#123;createTime&#125;)\n    &lt;/insert>\n\n    &lt;update id=\"updateStatus\">\n        update user set status = #&#123;status&#125; where id = #&#123;id&#125;\n    &lt;/update>\n&lt;/mapper>\n","slug":"MyBatis","date":"2023-03-02T16:00:00.000Z","categories_index":"","tags_index":"Spring","author_index":"Serena"},{"id":"cd53cdbf97b8f99c953dd3eda45eed25","title":"SpringMVC","content":"Spring MVC\n\n\n椤圭洰缁撴瀯\n\ncontroller 鎺 у 埗灞 �\ndao 鏁版嵁璁块棶灞 �\nservice 涓氬姟灞 �\nmodel 鏄  嚜甯︾粨鏋 �\n妯 ℃ 澘鏂囦欢鏀惧湪 templates\n\nmodel 鍜屾 ā 鏉挎枃浠堕 € 氳繃妯 ℃ 澘寮曟搸 Thymeleaf 褰 ㈡ 垚 HTML\nrequest&amp;response@RequestMapping(\"/http\")\npublic void http(HttpServletRequest request, HttpServletResponse response)&#123;\n    //鑾峰彇璇锋眰鏁版嵁\n    System.out.println(request.getMethod());\n    System.out.println(request.getServletPath());\n    Enumeration&lt;String> enumeration=request.getHeaderNames();\n    while (enumeration.hasMoreElements())&#123;\n        String name=enumeration.nextElement();\n        String value=request.getHeader(name);\n        System.out.println(name+\":\"+value);\n    &#125;\n    System.out.println(request.getParameter(\"code\"));\n\n    //杩斿洖鍝嶅簲鏁版嵁\n    response.setContentType(\"text/html;charset=utf-8\");\n    try(\n            PrintWriter writer=response.getWriter();\n            ) &#123;\n        //杈撳嚭娴�\n        writer.write(\"&lt;h1>瀛﹂櫌璁哄潧&lt;/h1>\");\n    &#125; catch (IOException e) &#123;\n        throw new RuntimeException(e);\n    &#125;\n    System.out.println();\n&#125;\n\n娴忚  鍣ㄦ樉绀猴細瀛﹂櫌璁哄潧\n\n鍛戒护琛屾樉绀猴細\nGET&#x2F;alpha&#x2F;httphost:localhost:8080connection:keep-alivesec-ch-ua:”Chromium”;v&#x3D;”110”, “Not A(Brand”;v&#x3D;”24”, “Microsoft Edge”;v&#x3D;”110”sec-ch-ua-mobile:?0sec-ch-ua-platform:”Windows”upgrade-insecure-requests:1user-agent:Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;110.0.0.0 Safari&#x2F;537.36 Edg&#x2F;110.0.1587.57accept:text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,&#x2F;;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.7sec-fetch-site:nonesec-fetch-mode:navigatesec-fetch-user:?1sec-fetch-dest:documentaccept-encoding:gzip, deflate, braccept-language:zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6cookie:Hm_lvt_eefa59dfd5fb29fcc57a8b2437ad5ab1&#x3D;1654502733,1654736646; Hm_lvt_e4027971a230b210f4671f485b33846a&#x3D;1677157216123\nGET 璇锋眰鐨勪袱绉嶄紶鍙傛柟寮 �// /student?current=1&amp;limit=20\n@RequestMapping(path=\"/students\",method = RequestMethod.GET)\n@ResponseBody\npublic String getStudent(\n        @RequestParam(name=\"current\",required=false,defaultValue=\"1\")int current,\n        @RequestParam(name=\"limit\",required=false,defaultValue=\"10\")int limit)&#123;\n    System.out.println(current);\n    System.out.println(limit);\n    return \"some students\";\n&#125;\n\n// /student/123\n@RequestMapping(path = \"/student/&#123;id&#125;\",method = RequestMethod.GET)\n@ResponseBody\npublic String getStudent(@PathVariable(\"id\") int id)&#123;\n    System.out.println(id);\n    return \"a student\";\n&#125;\n\nPOST 璇锋眰浼犲弬鍦ㄩ潤鎬侀〉闈 ㈠ 啓涓 € 涓 〃鍗 �\n&lt;form action=\"/community/alpha/student\" method=\"post\">\n  &lt;p>濮撳悕锛�&lt;input name=\"name\" tupe=\"text\" />&lt;/p>\n  &lt;p>骞撮緞锛�&lt;input name=\"age\" type=\"text\" />&lt;/p>\n  &lt;p>\n    &lt;input type=\"submit\" value=\"淇濆瓨\" />\n  &lt;/p>\n&lt;/form>\n\n//POST璇锋眰\n@RequestMapping(path = \"/student\",method = RequestMethod.POST)\n@ResponseBody\npublic String saveStudent(String name,int age)&#123;\n    System.out.println(name);\n    System.out.println(age);\n    return \"success\";\n&#125;\n\n鍙橀噺鍚嶇 О 鐩稿悓浼氳嚜鍔ㄨ幏鍙栵紙 get 鍚岀悊锛 �\n\n\n\n\n\n\n\n\n\nget 鐢ㄦ潵鑾峰彇鍙傛暟锛宲 ost 鐢ㄦ潵浼犲弬锛堝叾瀹 � get 涔熻兘浼犲弬锛屼絾鏄  暟鎹  兘鍦ㄨ矾寰勪笂锛屼笖璺  緞闀垮害鏈夐檺锛 �\n鍚戞祻瑙堝櫒鍝嶅簲鍔ㄦ €� html\n浣跨敤 ModelAndView\n\n//鍝嶅簲html\n@RequestMapping(path = \"/teacher\",method = RequestMethod.GET)\npublic ModelAndView getTeacher()&#123;\n    ModelAndView mav=new ModelAndView();\n    mav.addObject(\"name\",\"寮犱笁\");\n    mav.addObject(\"age\",\"30\");\n    mav.setViewName(\"/demo/view\");\n    return mav;\n&#125;\n\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n  &lt;head>\n    &lt;meta charset=\"UTF-8\" />\n    &lt;title>Teacher&lt;/title>\n  &lt;/head>\n  &lt;body>\n    &lt;p th:text=\"$&#123;name&#125;\">&lt;/p>\n    &lt;p th:text=\"$&#123;age&#125;\">&lt;/p>\n  &lt;/body>\n&lt;/html>\n\n\n浣跨敤 Model 锛岃繑鍥 � view 鐨 � path 锛屼氦缁 � dispatcherServlet\n\n@RequestMapping(path = \"/school\" ,method=RequestMethod.GET)\npublic String getSchool(Model model)&#123;\n  model.addAttribute(\"name\",\"鍖楀ぇ\");\n  model.addAttribute(\"age\",\"80\"); return \"/demo/view\";\n&#125;\n\n鍚戞祻瑙堝櫒鍝嶅簲 json 鏂囦欢閫氬父鐢ㄤ簬寮傛  璇锋眰锛屾瘮濡傛敞鍐屾椂鏄电 О 鏄  惁琚  崰鐢 �\nDispatcherServelt 妫 € 娴嬪埌 map 浼氳嚜鍔ㄨ浆鎹 ㈡ 垚 json 鏂囦欢\n@RequestMapping(path = \"/emp\",method = RequestMethod.GET)\n@ResponseBody\npublic Map&lt;String,Object> getEmp()&#123;\n    Map&lt;String,Object> emp=new HashMap&lt;>();\n    emp.put(\"name\",\"寮犱笁\");\n    emp.put(\"age\",\"23\");\n    emp.put(\"salary\",\"8000\");\n    return emp;\n&#125;\n\n娴忚  鍣ㄦ樉绀猴細\n&#123; \"name\": \"寮犱笁\", \"salary\": \"8000\", \"age\": \"23\" &#125;\n","slug":"SpringMVC","date":"2023-03-02T16:00:00.000Z","categories_index":"","tags_index":"Spring","author_index":"Serena"},{"id":"946249c65165e1a3d66f50e0cb6e89e7","title":"Spring","content":"Spring Boot 核心作用\n起步依赖\n\n​ 使用Spring Initializr进行项目配置：aop thymeleaf web devtools\n\n自动配置\n\n端点监控\n\n\nSpring IoC\nInversion of Control -控制反转，是一种面向对象编程的设计思想\n\nDependency Injection -依赖注入，IoC 的实现方式\n\nIoC Container -IoC 容器，实现依赖注入的关键，本质是一个工厂\n\n\n\nSpring&amp;Bean配置类底层自动创建 spring 容器\nApplicationContext 即 Spring 容器，这个接口继承于 BeanFactor（Spring 容器的顶层接口）\n@SpringBootApplication\npublic class CommunityApplication &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tSpringApplication.run(CommunityApplication.class, args);\n\t&#125;\n&#125;\n\n@SpringBootApplication 表明这是一个配置类进入 SpringBootApplication.java\n@SpringBootConfiguration\n@EnableAutoConfiguration //自动配置\n@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;) //扫描配置类所在包以及子包下的bean\n\nbean 内有相应注解才会被扫描\n@Controller //请求\nService //业务\nRepository //数据库访问\nComponent //通用\n\n均由 Component 实现\ngetBean()一个类想实现 Spring 容器，要实现 ApplicationContextAware 接口\n@SpringBootTest\n@ContextConfiguration(classes = CommunityApplication.class) //设置配置类\nclass CommunityApplicationTests implements ApplicationContextAware &#123;\n\tprivate ApplicationContext applicationContext;\n\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;\n\t\tthis.applicationContext=applicationContext;\n\t&#125;\n\n\t@Test\n\tpublic void testApplicationContext()&#123;\n\t\tSystem.out.println(applicationContext);\n\t&#125;\n&#125;\n\nAlphaDao alphadao&#x3D;applicationContext.getBean(AlphaDao.class); &#x2F;&#x2F;按类型获取bean\n\n如果 Bean 冲突了怎么办？在要获取的 Bean 加入\n\n\n\n\n\n\n\n\n\n@Primary\n或者给 Bean 起名字\n@Repository(\"AlphaHibernate\")\n\nalphadao=applicationContext.getBean(\"AlphaHibernate\",AlphaDao.class);\n\nBean 管理public  AlphaService()&#123;\n    System.out.println(\"实例化AlphaService\");\n&#125;\n\n@PostConstruct\npublic void init()&#123;\n    System.out.println(\"初始化AlphaService\");\n&#125;\n\n@PreDestroy\npublic void destory()&#123;\n    System.out.println(\"销毁AlphaService\");\n&#125;\n\n默认 Bean 是单例模式的，想要同样的类出现多个不同的 bean，需要注释\n@Scope(\"prototype\") //默认singleton\n\n如果想要导入第三方的 bean 怎么办？\n创建一个 config 文件\n@Configuration\npublic class AlphaConfig &#123;\n    @Bean\n    public SimpleDateFormat simpleDateFormat()&#123;\n        return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    &#125;\n&#125;\n\n更简单的方法？-&gt;依赖注入将 AlphaDao 注入 alphaDao\n@Autowired\n\tprivate AlphaDao alphaDao;\n\n指定注入的 bean\n@Autowired\n@Qualifier(&quot;AlphaHibernate&quot;)\nprivate AlphaDao alphaDao;\n\n请求的执行过程\n","slug":"Spring","date":"2023-02-28T16:00:00.000Z","categories_index":"","tags_index":"Spring","author_index":"Serena"},{"id":"cf26a6b1cbc6c769e4f860791ff7a888","title":"maven配置","content":"maven 命令使用maven 作用：构建项目，管理 jar 包技术文档：Maven – Maven in 5 Minutes (apache.org)\n配置中心仓库，镜像仓库\n查看版本\nmvn -version\n\n以 maven 自带模板建立一个项目（没有 class）\nmvn archetype:generate -DgroupId&#x3D;com.mycompany.app -DartifactId&#x3D;my-app -DarchetypeArtifactId&#x3D;maven-archetype-quickstart -DarchetypeVersion&#x3D;1.4 -DinteractiveMode&#x3D;false\n\n编译项目（出现 classes）\nmvn compile\n\n清空项目并测试（test-classes）\nmvn clean test\n\n\n找不到 org.junit，通过重新安装解决。。。\n依赖中出现了\n\n\n仍然不知道为什么\n","slug":"maven配置","date":"2023-02-28T08:36:26.000Z","categories_index":"","tags_index":"环境配置","author_index":"Serena"}]